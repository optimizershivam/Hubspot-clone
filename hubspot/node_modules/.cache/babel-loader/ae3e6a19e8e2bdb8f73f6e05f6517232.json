{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n/**\n * @public\n */\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * Pending animations that are started before a component is mounted.\n   * TODO: Remove this as animations should only run in effects\n   */\n\n  var pendingAnimations = [];\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function (visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function (definition, transitionOverride) {\n      /**\n       * TODO: We only perform this hasMounted check because in Framer we used to\n       * encourage the ability to start an animation within the render phase. This\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n       * we can ditch this.\n       */\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function (visualElement) {\n          animations_1.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function (definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function () {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function () {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_a) {\n        var animation = _a.animation,\n            resolve = _a.resolve;\n        controls.start.apply(controls, __spreadArray([], __read(animation), false)).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\nexport { animationControls };","map":{"version":3,"names":["__spreadArray","__read","invariant","stopAnimation","animateVisualElement","setValues","animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations_1","forEach","push","Promise","all","resolve","animation","set","stop","mount","_a","apply","then"],"sources":["C:/Users/Tejaswini Mahale/Desktop/boorish-earthquake-4077/hubspot/node_modules/framer-motion/dist/es/animation/animation-controls.mjs"],"sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.mjs';\nimport { setValues } from '../render/utils/setters.mjs';\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, __spreadArray([], __read(animation), false)).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,MAAxB,QAAsC,OAAtC;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,aAAT,EAAwBC,oBAAxB,QAAoD,+BAApD;AACA,SAASC,SAAT,QAA0B,6BAA1B;AAEA;AACA;AACA;;AACA,SAASC,iBAAT,GAA6B;EACzB;AACJ;AACA;EACI,IAAIC,UAAU,GAAG,KAAjB;EACA;AACJ;AACA;AACA;;EACI,IAAIC,iBAAiB,GAAG,EAAxB;EACA;AACJ;AACA;;EACI,IAAIC,WAAW,GAAG,IAAIC,GAAJ,EAAlB;EACA,IAAIC,QAAQ,GAAG;IACXC,SAAS,EAAE,UAAUC,aAAV,EAAyB;MAChCJ,WAAW,CAACK,GAAZ,CAAgBD,aAAhB;MACA,OAAO,YAAY;QAAE,OAAO,KAAKJ,WAAW,CAACM,MAAZ,CAAmBF,aAAnB,CAAZ;MAAgD,CAArE;IACH,CAJU;IAKXG,KAAK,EAAE,UAAUC,UAAV,EAAsBC,kBAAtB,EAA0C;MAC7C;AACZ;AACA;AACA;AACA;AACA;MACY,IAAIX,UAAJ,EAAgB;QACZ,IAAIY,YAAY,GAAG,EAAnB;QACAV,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;UACzCM,YAAY,CAACE,IAAb,CAAkBjB,oBAAoB,CAACS,aAAD,EAAgBI,UAAhB,EAA4B;YAC9DC,kBAAkB,EAAEA;UAD0C,CAA5B,CAAtC;QAGH,CAJD;QAKA,OAAOI,OAAO,CAACC,GAAR,CAAYJ,YAAZ,CAAP;MACH,CARD,MASK;QACD,OAAO,IAAIG,OAAJ,CAAY,UAAUE,OAAV,EAAmB;UAClChB,iBAAiB,CAACa,IAAlB,CAAuB;YACnBI,SAAS,EAAE,CAACR,UAAD,EAAaC,kBAAb,CADQ;YAEnBM,OAAO,EAAEA;UAFU,CAAvB;QAIH,CALM,CAAP;MAMH;IACJ,CA7BU;IA8BXE,GAAG,EAAE,UAAUT,UAAV,EAAsB;MACvBf,SAAS,CAACK,UAAD,EAAa,+GAAb,CAAT;MACA,OAAOE,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;QAChDR,SAAS,CAACQ,aAAD,EAAgBI,UAAhB,CAAT;MACH,CAFM,CAAP;IAGH,CAnCU;IAoCXU,IAAI,EAAE,YAAY;MACdlB,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;QACzCV,aAAa,CAACU,aAAD,CAAb;MACH,CAFD;IAGH,CAxCU;IAyCXe,KAAK,EAAE,YAAY;MACfrB,UAAU,GAAG,IAAb;MACAC,iBAAiB,CAACY,OAAlB,CAA0B,UAAUS,EAAV,EAAc;QACpC,IAAIJ,SAAS,GAAGI,EAAE,CAACJ,SAAnB;QAAA,IAA8BD,OAAO,GAAGK,EAAE,CAACL,OAA3C;QACAb,QAAQ,CAACK,KAAT,CAAec,KAAf,CAAqBnB,QAArB,EAA+BX,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACwB,SAAD,CAAX,EAAwB,KAAxB,CAA5C,EAA4EM,IAA5E,CAAiFP,OAAjF;MACH,CAHD;MAIA,OAAO,YAAY;QACfjB,UAAU,GAAG,KAAb;QACAI,QAAQ,CAACgB,IAAT;MACH,CAHD;IAIH;EAnDU,CAAf;EAqDA,OAAOhB,QAAP;AACH;;AAED,SAASL,iBAAT"},"metadata":{},"sourceType":"module"}