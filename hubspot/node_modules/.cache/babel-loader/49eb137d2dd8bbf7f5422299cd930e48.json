{"ast":null,"code":"import { __assign } from 'tslib';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { distance, pipe } from 'popmotion';\n/**\n * @internal\n */\n\nvar PanSession =\n/** @class */\nfunction () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n\n    var _b = _a === void 0 ? {} : _a,\n        transformPagePoint = _b.transformPagePoint;\n    /**\n     * @internal\n     */\n\n\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      var isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = getFrameData().timestamp;\n\n      _this.history.push(__assign(__assign({}, point), {\n        timestamp: timestamp\n      }));\n\n      var _a = _this.handlers,\n          onStart = _a.onStart,\n          onMove = _a.onMove;\n\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = function (event, info) {\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.handlePointerUp(event, info);\n\n        return;\n      } // Throttle mouse move event to once per frame\n\n\n      sync.update(_this.updatePoint, true);\n    };\n\n    this.handlePointerUp = function (event, info) {\n      _this.end();\n\n      var _a = _this.handlers,\n          onEnd = _a.onEnd,\n          onSessionEnd = _a.onSessionEnd;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  };\n\n  return PanSession;\n}();\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nexport { PanSession };","map":{"version":3,"names":["__assign","isMouseEvent","isTouchEvent","extractEventInfo","sync","getFrameData","cancelSync","secondsToMilliseconds","addPointerEvent","distance","pipe","PanSession","event","handlers","_a","_this","_b","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","onSessionEnd","panInfo","touches","length","initialInfo","onSessionStart","removeListeners","window","prototype","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["C:/Users/Tejaswini Mahale/Desktop/Hubspot/hubspot/node_modules/framer-motion/dist/es/gestures/PanSession.mjs"],"sourcesContent":["import { __assign } from 'tslib';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { distance, pipe } from 'popmotion';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}