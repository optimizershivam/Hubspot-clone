{"ast":null,"code":"import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement } from '@formatjs/icu-messageformat-parser';\nimport { MissingValueError, InvalidValueError, ErrorCode, FormatError, InvalidValueTypeError } from './error';\nexport var PART_TYPE;\n\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\n\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n\n    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {\n      all.push(part);\n    } else {\n      lastPart.value += part.value;\n    }\n\n    return all;\n  }, []);\n}\n\nexport function isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n} // TODO(skeleton): add skeleton support\n\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, // For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && isLiteralElement(els[0])) {\n    return [{\n      type: PART_TYPE.literal,\n      value: els[0].value\n    }];\n  }\n\n  var result = [];\n\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i]; // Exit early for string parts.\n\n    if (isLiteralElement(el)) {\n      result.push({\n        type: PART_TYPE.literal,\n        value: el.value\n      });\n      continue;\n    } // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n\n\n    if (isPoundElement(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: PART_TYPE.literal,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n\n      continue;\n    }\n\n    var varName = el.value; // Enforce that all required values are provided by the caller.\n\n    if (!(values && varName in values)) {\n      throw new MissingValueError(varName, originalMessage);\n    }\n\n    var value = values[varName];\n\n    if (isArgumentElement(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n\n      result.push({\n        type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n        value: value\n      });\n      continue;\n    } // Recursively format plural and select parts' option — which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n\n\n    if (isDateElement(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTimeElement(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isNumberElement(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : undefined;\n\n      if (style && style.scale) {\n        value = value * (style.scale || 1);\n      }\n\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n\n    if (isTagElement(el)) {\n      var children = el.children,\n          value_1 = el.value;\n      var formatFn = values[value_1];\n\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn(parts.map(function (p) {\n        return p.value;\n      }));\n\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n          value: c\n        };\n      }));\n    }\n\n    if (isSelectElement(el)) {\n      var opt = el.options[value] || el.options.other;\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n\n    if (isPluralElement(el)) {\n      var opt = el.options[\"=\".concat(value)];\n\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", ErrorCode.MISSING_INTL_API, originalMessage);\n        }\n\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n\n  return mergeLiteral(result);\n}","map":{"version":3,"names":["isArgumentElement","isDateElement","isDateTimeSkeleton","isLiteralElement","isNumberElement","isNumberSkeleton","isPluralElement","isPoundElement","isSelectElement","isTimeElement","isTagElement","MissingValueError","InvalidValueError","ErrorCode","FormatError","InvalidValueTypeError","PART_TYPE","mergeLiteral","parts","length","reduce","all","part","lastPart","type","literal","push","value","isFormatXMLElementFn","el","formatToParts","els","locales","formatters","formats","values","currentPluralValue","originalMessage","result","_i","els_1","getNumberFormat","format","varName","String","object","style","date","parsedOptions","undefined","getDateTimeFormat","time","medium","number","scale","children","value_1","formatFn","chunks","map","p","Array","isArray","apply","c","opt","options","other","Object","keys","concat","Intl","PluralRules","MISSING_INTL_API","rule","getPluralRules","pluralType","select","offset"],"sources":["C:/Users/Tejaswini Mahale/Desktop/Hubspot/hubspot/node_modules/intl-messageformat/lib/src/formatters.js"],"sourcesContent":["import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement, } from '@formatjs/icu-messageformat-parser';\nimport { MissingValueError, InvalidValueError, ErrorCode, FormatError, InvalidValueTypeError, } from './error';\nexport var PART_TYPE;\n(function (PART_TYPE) {\n    PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n    PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n    if (parts.length < 2) {\n        return parts;\n    }\n    return parts.reduce(function (all, part) {\n        var lastPart = all[all.length - 1];\n        if (!lastPart ||\n            lastPart.type !== PART_TYPE.literal ||\n            part.type !== PART_TYPE.literal) {\n            all.push(part);\n        }\n        else {\n            lastPart.value += part.value;\n        }\n        return all;\n    }, []);\n}\nexport function isFormatXMLElementFn(el) {\n    return typeof el === 'function';\n}\n// TODO(skeleton): add skeleton support\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue, \n// For debugging\noriginalMessage) {\n    // Hot path for straight simple msg translations\n    if (els.length === 1 && isLiteralElement(els[0])) {\n        return [\n            {\n                type: PART_TYPE.literal,\n                value: els[0].value,\n            },\n        ];\n    }\n    var result = [];\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n        var el = els_1[_i];\n        // Exit early for string parts.\n        if (isLiteralElement(el)) {\n            result.push({\n                type: PART_TYPE.literal,\n                value: el.value,\n            });\n            continue;\n        }\n        // TODO: should this part be literal type?\n        // Replace `#` in plural rules with the actual numeric value.\n        if (isPoundElement(el)) {\n            if (typeof currentPluralValue === 'number') {\n                result.push({\n                    type: PART_TYPE.literal,\n                    value: formatters.getNumberFormat(locales).format(currentPluralValue),\n                });\n            }\n            continue;\n        }\n        var varName = el.value;\n        // Enforce that all required values are provided by the caller.\n        if (!(values && varName in values)) {\n            throw new MissingValueError(varName, originalMessage);\n        }\n        var value = values[varName];\n        if (isArgumentElement(el)) {\n            if (!value || typeof value === 'string' || typeof value === 'number') {\n                value =\n                    typeof value === 'string' || typeof value === 'number'\n                        ? String(value)\n                        : '';\n            }\n            result.push({\n                type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n                value: value,\n            });\n            continue;\n        }\n        // Recursively format plural and select parts' option — which can be a\n        // nested pattern structure. The choosing of the option to use is\n        // abstracted-by and delegated-to the part helper object.\n        if (isDateElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.date[el.style]\n                : isDateTimeSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isTimeElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.time[el.style]\n                : isDateTimeSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : formats.time.medium;\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getDateTimeFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isNumberElement(el)) {\n            var style = typeof el.style === 'string'\n                ? formats.number[el.style]\n                : isNumberSkeleton(el.style)\n                    ? el.style.parsedOptions\n                    : undefined;\n            if (style && style.scale) {\n                value =\n                    value *\n                        (style.scale || 1);\n            }\n            result.push({\n                type: PART_TYPE.literal,\n                value: formatters\n                    .getNumberFormat(locales, style)\n                    .format(value),\n            });\n            continue;\n        }\n        if (isTagElement(el)) {\n            var children = el.children, value_1 = el.value;\n            var formatFn = values[value_1];\n            if (!isFormatXMLElementFn(formatFn)) {\n                throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n            }\n            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n            var chunks = formatFn(parts.map(function (p) { return p.value; }));\n            if (!Array.isArray(chunks)) {\n                chunks = [chunks];\n            }\n            result.push.apply(result, chunks.map(function (c) {\n                return {\n                    type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n                    value: c,\n                };\n            }));\n        }\n        if (isSelectElement(el)) {\n            var opt = el.options[value] || el.options.other;\n            if (!opt) {\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n            continue;\n        }\n        if (isPluralElement(el)) {\n            var opt = el.options[\"=\".concat(value)];\n            if (!opt) {\n                if (!Intl.PluralRules) {\n                    throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", ErrorCode.MISSING_INTL_API, originalMessage);\n                }\n                var rule = formatters\n                    .getPluralRules(locales, { type: el.pluralType })\n                    .select(value - (el.offset || 0));\n                opt = el.options[rule] || el.options.other;\n            }\n            if (!opt) {\n                throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n            }\n            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n            continue;\n        }\n    }\n    return mergeLiteral(result);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}