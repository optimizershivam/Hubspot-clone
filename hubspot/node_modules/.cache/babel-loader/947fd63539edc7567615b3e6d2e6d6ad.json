{"ast":null,"code":"var _a;\n\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton } from '@formatjs/icu-skeleton-parser';\nimport { getBestPattern } from './date-time-pattern-generator';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(SPACE_SEPARATOR_REGEX.source, \"*$\"));\n\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n} // #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\n\n\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n}; // IE11 does not support y and u.\n\nvar REGEX_SUPPORTS_U_AND_Y = true;\n\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\n   * legacy Edge or Xbox One browser\n   * Unicode flag support: supported\n   * Pattern_Syntax support: not supported\n   * See https://github.com/formatjs/formatjs/issues/2822\n   */\n\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\n\nvar startsWith = hasNativeStartsWith ? // Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} : // For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : // IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n\n  return elements;\n};\nvar fromEntries = // native\nhasNativeFromEntries ? Object.fromEntries : // Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n        k = _a[0],\n        v = _a[1];\n    obj[k] = v;\n  }\n\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ? // Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} : // IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ? // Native\nfunction trimStart(s) {\n  return s.trimStart();\n} : // Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ? // Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} : // Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n}; // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\n\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n} // #endregion\n\n\nvar matchIdentifierAtIndex;\n\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n\n    while (true) {\n      var c = codePointAt(s, index);\n\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n\n    return fromCodePoint.apply(void 0, match);\n  };\n}\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.locale = options.locale;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n\n    return this.parseMessage(0, '', false);\n  };\n\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n\n    while (!this.isEOF()) {\n      var char = this.char();\n\n      if (char === 123\n      /* `{` */\n      ) {\n        var result = this.parseArgument(nestingLevel, expectingCloseTag);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else if (char === 125\n      /* `}` */\n      && nestingLevel > 0) {\n        break;\n      } else if (char === 35\n      /* `#` */\n      && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n        if (expectingCloseTag) {\n          break;\n        } else {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      }\n    }\n\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n   * are accepted:\n   *\n   * ```\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n   * tagName ::= [a-z] (PENChar)*\n   * PENChar ::=\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n   * ```\n   *\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n   * since other tag-based engines like React allow it\n   */\n\n\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: TYPE.literal,\n          value: \"<\".concat(tagName, \"/>\"),\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n\n      var children = childrenResult.val; // Expecting a close tag\n\n      var endTagStartPosition = this.clonePosition();\n\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n\n        if (tagName !== closingTagName) {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n\n        this.bumpSpace();\n\n        if (!this.bumpIf('>')) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        return {\n          val: {\n            type: TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\n   * This method assumes that the caller has peeked ahead for the first tag character.\n   */\n\n\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n\n    return this.message.slice(startOffset, this.offset());\n  };\n\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n\n      break;\n    }\n\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60\n    /* `<` */\n    && (this.ignoreTag || // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n\n      return '<';\n    }\n\n    return null;\n  };\n  /**\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n   */\n\n\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39\n    /* `'` */\n    ) {\n      return null;\n    } // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n\n\n    switch (this.peek()) {\n      case 39\n      /* `'` */\n      :\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n\n    this.bump(); // apostrophe\n\n    var codePoints = [this.char()]; // escaped char\n\n    this.bump(); // read chars until the optional closing apostrophe is found\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch === 39\n      /* `'` */\n      ) {\n        if (this.peek() === 39\n        /* `'` */\n        ) {\n          codePoints.push(39); // Bump one more time because we need to skip 2 characters.\n\n          this.bump();\n        } else {\n          // Optional closing apostrophe.\n          this.bump();\n          break;\n        }\n      } else {\n        codePoints.push(ch);\n      }\n\n      this.bump();\n    }\n\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var ch = this.char();\n\n    if (ch === 60\n    /* `<` */\n    || ch === 123\n    /* `{` */\n    || ch === 35\n    /* `#` */\n    && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125\n    /* `}` */\n    && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    if (this.char() === 125\n    /* `}` */\n    ) {\n      this.bump();\n      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    } // argument name\n\n\n    var value = this.parseIdentifierIfPossible().value;\n\n    if (!value) {\n      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125\n      /* `}` */\n      :\n        {\n          this.bump(); // `}`\n\n          return {\n            val: {\n              type: TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n\n      case 44\n      /* `,` */\n      :\n        {\n          this.bump(); // `,`\n\n          this.bumpSpace();\n\n          if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n\n      default:\n        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\n   * Advance the parser until the end of the identifier, if it is currently on\n   * an identifier character. Return an empty string otherwise.\n   */\n\n\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a; // Parse this range:\n    // {name, type, style}\n    //        ^---^\n\n\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n\n            if (result.err) {\n              return result;\n            }\n\n            var style = trimEnd(result.val);\n\n            if (style.length === 0) {\n              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_1 = createLocation(openingBracePosition, this.clonePosition()); // Extract style or skeleton\n\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n\n              if (result.err) {\n                return result;\n              }\n\n              return {\n                val: {\n                  type: TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n\n              var dateTimePattern = skeleton; // Get \"best match\" pattern only if locale is passed, if not, let it\n              // pass as-is where `parseDateTimeSkeleton()` will throw an error\n              // for unsupported patterns.\n\n              if (this.locale) {\n                dateTimePattern = getBestPattern(skeleton, this.locale);\n              }\n\n              var style = {\n                type: SKELETON_TYPE.dateTime,\n                pattern: dateTimePattern,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(dateTimePattern) : {}\n              };\n              var type = argType === 'date' ? TYPE.date : TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          } // Regular style or no style.\n\n\n          return {\n            val: {\n              type: argType === 'number' ? TYPE.number : argType === 'date' ? TYPE.date : TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n\n          if (!this.bumpIf(',')) {\n            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n          }\n\n          this.bumpSpace(); // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n\n            if (result.err) {\n              return result;\n            } // Parse another identifier for option parsing\n\n\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n\n          if (argType === 'select') {\n            return {\n              val: {\n                type: TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n\n      default:\n        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125\n    /* `}` */\n    ) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bump(); // `}`\n\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n   */\n\n\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      switch (ch) {\n        case 39\n        /* `'` */\n        :\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n\n            this.bump();\n            break;\n          }\n\n        case 123\n        /* `{` */\n        :\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n\n        case 125\n        /* `}` */\n        :\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n\n            break;\n          }\n\n        default:\n          this.bump();\n          break;\n      }\n    }\n\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n\n    try {\n      tokens = parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n\n    return {\n      val: {\n        type: SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\n   * @param nesting_level The current nesting level of messages.\n   *     This can be positive when parsing message fragment in select or plural argument options.\n   * @param parent_arg_type The parent argument's type.\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n   *     the argument. It is a by-product of a previous parsing attempt.\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\n   *     the closing tag boundary.\n   */\n\n\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n        selectorLocation = parsedFirstIdentifier.location; // Parse:\n    // one {one apple}\n    // ^--^\n\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n\n          if (result.err) {\n            return result;\n          }\n\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      } // Duplicate selector clauses\n\n\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n\n      if (selector === 'other') {\n        hasOtherClause = true;\n      } // Parse:\n      // one {one apple}\n      //     ^----------^\n\n\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]); // Keep track of the existing selectors\n\n      parsedSelectors.add(selector); // Prep next selector clause.\n\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    return {\n      val: options,\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n\n    var hasDigits = false;\n    var decimal = 0;\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch >= 48\n      /* `0` */\n      && ch <= 57\n      /* `9` */\n      ) {\n        hasDigits = true;\n        decimal = decimal * 10 + (ch - 48);\n        this.bump();\n      } else {\n        break;\n      }\n    }\n\n    var location = createLocation(startingPosition, this.clonePosition());\n\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n\n    decimal *= sign;\n\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\n   * Return the code point at the current position of the parser.\n   * Throws if the index is out of bound.\n   */\n\n\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n\n    var code = codePointAt(this.message, offset);\n\n    if (code === undefined) {\n      throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n    }\n\n    return code;\n  };\n\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n\n\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n\n    var code = this.char();\n\n    if (code === 10\n    /* '\\n' */\n    ) {\n      this.position.line += 1;\n      this.position.column = 1;\n      this.position.offset += 1;\n    } else {\n      this.position.column += 1; // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\n   * If the substring starting at the current position of the parser has\n   * the given prefix, then bump the parser to the character immediately\n   * following the prefix and return true. Otherwise, don't bump the parser\n   * and return false.\n   */\n\n\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Bump the parser until the pattern character is found and return `true`.\n   * Otherwise bump to the end of the file and return `false`.\n   */\n\n\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\n   * Bump the parser to the target offset.\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\n   */\n\n\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n    }\n\n    targetOffset = Math.min(targetOffset, this.message.length);\n\n    while (true) {\n      var offset = this.offset();\n\n      if (offset === targetOffset) {\n        break;\n      }\n\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n      }\n\n      this.bump();\n\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n\n\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n   * If the input has been exhausted, then this returns null.\n   */\n\n\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\n\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\n\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47;\n  /* '/' */\n}\n/** See `parseTag` function docs. */\n\n\nfunction _isPotentialElementNameChar(c) {\n  return c === 45\n  /* '-' */\n  || c === 46\n  /* '.' */\n  || c >= 48 && c <= 57\n  /* 0..9 */\n  || c === 95\n  /* '_' */\n  || c >= 97 && c <= 122\n  /** a..z */\n  || c >= 65 && c <= 90\n  /* A..Z */\n  || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","map":{"version":3,"names":["_a","__assign","ErrorKind","SKELETON_TYPE","TYPE","SPACE_SEPARATOR_REGEX","parseNumberSkeleton","parseNumberSkeletonFromString","parseDateTimeSkeleton","getBestPattern","SPACE_SEPARATOR_START_REGEX","RegExp","concat","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","Object","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","hasNativeIsSafeInteger","Number","isSafeInteger","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","re","RE","exec","_","s","search","position","slice","length","codePoints","_i","arguments","elements","i","code","RangeError","fromCharCode","entries","obj","entries_1","k","v","index","size","undefined","first","charCodeAt","second","replace","flag","matchIdentifierAtIndex","IDENTIFIER_PREFIX_RE_1","lastIndex","match","c","_isWhiteSpace","_isPatternSyntax","push","apply","Parser","message","options","offset","line","column","ignoreTag","locale","requiresOtherClause","shouldParseSkeletons","parse","Error","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","result","parseArgument","err","val","clonePosition","bump","type","pound","location","peek","error","UNMATCHED_CLOSING_TAG","_isAlpha","parseTag","parseLiteral","startPosition","tagName","parseTagName","bumpSpace","bumpIf","literal","value","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","closingTagName","tag","UNCLOSED_TAG","startOffset","_isPotentialElementNameChar","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","_isAlphaOrSlash","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","argument","parseArgumentOptions","startingPosition","endOffset","bumpTo","endPosition","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","style","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","skeleton","number","EXPECT_DATE_TIME_SKELETON","dateTimePattern","dateTime","pattern","parsedOptions","date","time","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","select","plural","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","tokens","e","INVALID_NUMBER_SKELETON","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","codepoint"],"sources":["C:/Users/Tejaswini Mahale/Desktop/Hubspot/hubspot/node_modules/@formatjs/icu-messageformat-parser/lib/parser.js"],"sourcesContent":["var _a;\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE, } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton, } from '@formatjs/icu-skeleton-parser';\nimport { getBestPattern } from './date-time-pattern-generator';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(SPACE_SEPARATOR_REGEX.source, \"*$\"));\nfunction createLocation(start, end) {\n    return { start: start, end: end };\n}\n// #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger\n    ? Number.isSafeInteger\n    : function (n) {\n        return (typeof n === 'number' &&\n            isFinite(n) &&\n            Math.floor(n) === n &&\n            Math.abs(n) <= 0x1fffffffffffff);\n    };\n// IE11 does not support y and u.\nvar REGEX_SUPPORTS_U_AND_Y = true;\ntry {\n    var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    /**\n     * legacy Edge or Xbox One browser\n     * Unicode flag support: supported\n     * Pattern_Syntax support: not supported\n     * See https://github.com/formatjs/formatjs/issues/2822\n     */\n    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n}\ncatch (_) {\n    REGEX_SUPPORTS_U_AND_Y = false;\n}\nvar startsWith = hasNativeStartsWith\n    ? // Native\n        function startsWith(s, search, position) {\n            return s.startsWith(search, position);\n        }\n    : // For IE11\n        function startsWith(s, search, position) {\n            return s.slice(position, position + search.length) === search;\n        };\nvar fromCodePoint = hasNativeFromCodePoint\n    ? String.fromCodePoint\n    : // IE11\n        function fromCodePoint() {\n            var codePoints = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                codePoints[_i] = arguments[_i];\n            }\n            var elements = '';\n            var length = codePoints.length;\n            var i = 0;\n            var code;\n            while (length > i) {\n                code = codePoints[i++];\n                if (code > 0x10ffff)\n                    throw RangeError(code + ' is not a valid code point');\n                elements +=\n                    code < 0x10000\n                        ? String.fromCharCode(code)\n                        : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);\n            }\n            return elements;\n        };\nvar fromEntries = \n// native\nhasNativeFromEntries\n    ? Object.fromEntries\n    : // Ponyfill\n        function fromEntries(entries) {\n            var obj = {};\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                obj[k] = v;\n            }\n            return obj;\n        };\nvar codePointAt = hasNativeCodePointAt\n    ? // Native\n        function codePointAt(s, index) {\n            return s.codePointAt(index);\n        }\n    : // IE 11\n        function codePointAt(s, index) {\n            var size = s.length;\n            if (index < 0 || index >= size) {\n                return undefined;\n            }\n            var first = s.charCodeAt(index);\n            var second;\n            return first < 0xd800 ||\n                first > 0xdbff ||\n                index + 1 === size ||\n                (second = s.charCodeAt(index + 1)) < 0xdc00 ||\n                second > 0xdfff\n                ? first\n                : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;\n        };\nvar trimStart = hasTrimStart\n    ? // Native\n        function trimStart(s) {\n            return s.trimStart();\n        }\n    : // Ponyfill\n        function trimStart(s) {\n            return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n        };\nvar trimEnd = hasTrimEnd\n    ? // Native\n        function trimEnd(s) {\n            return s.trimEnd();\n        }\n    : // Ponyfill\n        function trimEnd(s) {\n            return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n        };\n// Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\nfunction RE(s, flag) {\n    return new RegExp(s, flag);\n}\n// #endregion\nvar matchIdentifierAtIndex;\nif (REGEX_SUPPORTS_U_AND_Y) {\n    // Native\n    var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var _a;\n        IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n        var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n        return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n    };\n}\nelse {\n    // IE11\n    matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n        var match = [];\n        while (true) {\n            var c = codePointAt(s, index);\n            if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n                break;\n            }\n            match.push(c);\n            index += c >= 0x10000 ? 2 : 1;\n        }\n        return fromCodePoint.apply(void 0, match);\n    };\n}\nvar Parser = /** @class */ (function () {\n    function Parser(message, options) {\n        if (options === void 0) { options = {}; }\n        this.message = message;\n        this.position = { offset: 0, line: 1, column: 1 };\n        this.ignoreTag = !!options.ignoreTag;\n        this.locale = options.locale;\n        this.requiresOtherClause = !!options.requiresOtherClause;\n        this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n    }\n    Parser.prototype.parse = function () {\n        if (this.offset() !== 0) {\n            throw Error('parser can only be used once');\n        }\n        return this.parseMessage(0, '', false);\n    };\n    Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n        var elements = [];\n        while (!this.isEOF()) {\n            var char = this.char();\n            if (char === 123 /* `{` */) {\n                var result = this.parseArgument(nestingLevel, expectingCloseTag);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else if (char === 125 /* `}` */ && nestingLevel > 0) {\n                break;\n            }\n            else if (char === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n                var position = this.clonePosition();\n                this.bump();\n                elements.push({\n                    type: TYPE.pound,\n                    location: createLocation(position, this.clonePosition()),\n                });\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                this.peek() === 47 // char code for '/'\n            ) {\n                if (expectingCloseTag) {\n                    break;\n                }\n                else {\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n                }\n            }\n            else if (char === 60 /* `<` */ &&\n                !this.ignoreTag &&\n                _isAlpha(this.peek() || 0)) {\n                var result = this.parseTag(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n            else {\n                var result = this.parseLiteral(nestingLevel, parentArgType);\n                if (result.err) {\n                    return result;\n                }\n                elements.push(result.val);\n            }\n        }\n        return { val: elements, err: null };\n    };\n    /**\n     * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n     * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n     * are accepted:\n     *\n     * ```\n     * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n     * tagName ::= [a-z] (PENChar)*\n     * PENChar ::=\n     *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n     *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n     *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n     * ```\n     *\n     * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n     * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n     * since other tag-based engines like React allow it\n     */\n    Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n        var startPosition = this.clonePosition();\n        this.bump(); // `<`\n        var tagName = this.parseTagName();\n        this.bumpSpace();\n        if (this.bumpIf('/>')) {\n            // Self closing tag\n            return {\n                val: {\n                    type: TYPE.literal,\n                    value: \"<\".concat(tagName, \"/>\"),\n                    location: createLocation(startPosition, this.clonePosition()),\n                },\n                err: null,\n            };\n        }\n        else if (this.bumpIf('>')) {\n            var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n            if (childrenResult.err) {\n                return childrenResult;\n            }\n            var children = childrenResult.val;\n            // Expecting a close tag\n            var endTagStartPosition = this.clonePosition();\n            if (this.bumpIf('</')) {\n                if (this.isEOF() || !_isAlpha(this.char())) {\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                var closingTagNameStartPosition = this.clonePosition();\n                var closingTagName = this.parseTagName();\n                if (tagName !== closingTagName) {\n                    return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n                }\n                this.bumpSpace();\n                if (!this.bumpIf('>')) {\n                    return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n                }\n                return {\n                    val: {\n                        type: TYPE.tag,\n                        value: tagName,\n                        children: children,\n                        location: createLocation(startPosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            else {\n                return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n            }\n        }\n        else {\n            return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n        }\n    };\n    /**\n     * This method assumes that the caller has peeked ahead for the first tag character.\n     */\n    Parser.prototype.parseTagName = function () {\n        var startOffset = this.offset();\n        this.bump(); // the first tag name character\n        while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n            this.bump();\n        }\n        return this.message.slice(startOffset, this.offset());\n    };\n    Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n        var start = this.clonePosition();\n        var value = '';\n        while (true) {\n            var parseQuoteResult = this.tryParseQuote(parentArgType);\n            if (parseQuoteResult) {\n                value += parseQuoteResult;\n                continue;\n            }\n            var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n            if (parseUnquotedResult) {\n                value += parseUnquotedResult;\n                continue;\n            }\n            var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n            if (parseLeftAngleResult) {\n                value += parseLeftAngleResult;\n                continue;\n            }\n            break;\n        }\n        var location = createLocation(start, this.clonePosition());\n        return {\n            val: { type: TYPE.literal, value: value, location: location },\n            err: null,\n        };\n    };\n    Parser.prototype.tryParseLeftAngleBracket = function () {\n        if (!this.isEOF() &&\n            this.char() === 60 /* `<` */ &&\n            (this.ignoreTag ||\n                // If at the opening tag or closing tag position, bail.\n                !_isAlphaOrSlash(this.peek() || 0))) {\n            this.bump(); // `<`\n            return '<';\n        }\n        return null;\n    };\n    /**\n     * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n     * a character that requires quoting (that is, \"only where needed\"), and works the same in\n     * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n     */\n    Parser.prototype.tryParseQuote = function (parentArgType) {\n        if (this.isEOF() || this.char() !== 39 /* `'` */) {\n            return null;\n        }\n        // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n        // Check if is valid escaped character\n        switch (this.peek()) {\n            case 39 /* `'` */:\n                // double quote, should return as a single quote.\n                this.bump();\n                this.bump();\n                return \"'\";\n            // '{', '<', '>', '}'\n            case 123:\n            case 60:\n            case 62:\n            case 125:\n                break;\n            case 35: // '#'\n                if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n                    break;\n                }\n                return null;\n            default:\n                return null;\n        }\n        this.bump(); // apostrophe\n        var codePoints = [this.char()]; // escaped char\n        this.bump();\n        // read chars until the optional closing apostrophe is found\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch === 39 /* `'` */) {\n                if (this.peek() === 39 /* `'` */) {\n                    codePoints.push(39);\n                    // Bump one more time because we need to skip 2 characters.\n                    this.bump();\n                }\n                else {\n                    // Optional closing apostrophe.\n                    this.bump();\n                    break;\n                }\n            }\n            else {\n                codePoints.push(ch);\n            }\n            this.bump();\n        }\n        return fromCodePoint.apply(void 0, codePoints);\n    };\n    Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n        if (this.isEOF()) {\n            return null;\n        }\n        var ch = this.char();\n        if (ch === 60 /* `<` */ ||\n            ch === 123 /* `{` */ ||\n            (ch === 35 /* `#` */ &&\n                (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||\n            (ch === 125 /* `}` */ && nestingLevel > 0)) {\n            return null;\n        }\n        else {\n            this.bump();\n            return fromCodePoint(ch);\n        }\n    };\n    Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n        var openingBracePosition = this.clonePosition();\n        this.bump(); // `{`\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        if (this.char() === 125 /* `}` */) {\n            this.bump();\n            return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        // argument name\n        var value = this.parseIdentifierIfPossible().value;\n        if (!value) {\n            return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bumpSpace();\n        if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        switch (this.char()) {\n            // Simple argument: `{name}`\n            case 125 /* `}` */: {\n                this.bump(); // `}`\n                return {\n                    val: {\n                        type: TYPE.argument,\n                        // value does not include the opening and closing braces.\n                        value: value,\n                        location: createLocation(openingBracePosition, this.clonePosition()),\n                    },\n                    err: null,\n                };\n            }\n            // Argument with options: `{name, format, ...}`\n            case 44 /* `,` */: {\n                this.bump(); // `,`\n                this.bumpSpace();\n                if (this.isEOF()) {\n                    return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n                }\n                return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n            }\n            default:\n                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n        }\n    };\n    /**\n     * Advance the parser until the end of the identifier, if it is currently on\n     * an identifier character. Return an empty string otherwise.\n     */\n    Parser.prototype.parseIdentifierIfPossible = function () {\n        var startingPosition = this.clonePosition();\n        var startOffset = this.offset();\n        var value = matchIdentifierAtIndex(this.message, startOffset);\n        var endOffset = startOffset + value.length;\n        this.bumpTo(endOffset);\n        var endPosition = this.clonePosition();\n        var location = createLocation(startingPosition, endPosition);\n        return { value: value, location: location };\n    };\n    Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n        var _a;\n        // Parse this range:\n        // {name, type, style}\n        //        ^---^\n        var typeStartPosition = this.clonePosition();\n        var argType = this.parseIdentifierIfPossible().value;\n        var typeEndPosition = this.clonePosition();\n        switch (argType) {\n            case '':\n                // Expecting a style string number, date, time, plural, selectordinal, or select.\n                return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n            case 'number':\n            case 'date':\n            case 'time': {\n                // Parse this range:\n                // {name, number, style}\n                //              ^-------^\n                this.bumpSpace();\n                var styleAndLocation = null;\n                if (this.bumpIf(',')) {\n                    this.bumpSpace();\n                    var styleStartPosition = this.clonePosition();\n                    var result = this.parseSimpleArgStyleIfPossible();\n                    if (result.err) {\n                        return result;\n                    }\n                    var style = trimEnd(result.val);\n                    if (style.length === 0) {\n                        return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n                    styleAndLocation = { style: style, styleLocation: styleLocation };\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_1 = createLocation(openingBracePosition, this.clonePosition());\n                // Extract style or skeleton\n                if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n                    // Skeleton starts with `::`.\n                    var skeleton = trimStart(styleAndLocation.style.slice(2));\n                    if (argType === 'number') {\n                        var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n                        if (result.err) {\n                            return result;\n                        }\n                        return {\n                            val: { type: TYPE.number, value: value, location: location_1, style: result.val },\n                            err: null,\n                        };\n                    }\n                    else {\n                        if (skeleton.length === 0) {\n                            return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n                        }\n                        var dateTimePattern = skeleton;\n                        // Get \"best match\" pattern only if locale is passed, if not, let it\n                        // pass as-is where `parseDateTimeSkeleton()` will throw an error\n                        // for unsupported patterns.\n                        if (this.locale) {\n                            dateTimePattern = getBestPattern(skeleton, this.locale);\n                        }\n                        var style = {\n                            type: SKELETON_TYPE.dateTime,\n                            pattern: dateTimePattern,\n                            location: styleAndLocation.styleLocation,\n                            parsedOptions: this.shouldParseSkeletons\n                                ? parseDateTimeSkeleton(dateTimePattern)\n                                : {},\n                        };\n                        var type = argType === 'date' ? TYPE.date : TYPE.time;\n                        return {\n                            val: { type: type, value: value, location: location_1, style: style },\n                            err: null,\n                        };\n                    }\n                }\n                // Regular style or no style.\n                return {\n                    val: {\n                        type: argType === 'number'\n                            ? TYPE.number\n                            : argType === 'date'\n                                ? TYPE.date\n                                : TYPE.time,\n                        value: value,\n                        location: location_1,\n                        style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,\n                    },\n                    err: null,\n                };\n            }\n            case 'plural':\n            case 'selectordinal':\n            case 'select': {\n                // Parse this range:\n                // {name, plural, options}\n                //              ^---------^\n                var typeEndPosition_1 = this.clonePosition();\n                this.bumpSpace();\n                if (!this.bumpIf(',')) {\n                    return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n                }\n                this.bumpSpace();\n                // Parse offset:\n                // {name, plural, offset:1, options}\n                //                ^-----^\n                //\n                // or the first option:\n                //\n                // {name, plural, one {...} other {...}}\n                //                ^--^\n                var identifierAndLocation = this.parseIdentifierIfPossible();\n                var pluralOffset = 0;\n                if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n                    if (!this.bumpIf(':')) {\n                        return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n                    }\n                    this.bumpSpace();\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n                    if (result.err) {\n                        return result;\n                    }\n                    // Parse another identifier for option parsing\n                    this.bumpSpace();\n                    identifierAndLocation = this.parseIdentifierIfPossible();\n                    pluralOffset = result.val;\n                }\n                var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n                if (optionsResult.err) {\n                    return optionsResult;\n                }\n                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n                if (argCloseResult.err) {\n                    return argCloseResult;\n                }\n                var location_2 = createLocation(openingBracePosition, this.clonePosition());\n                if (argType === 'select') {\n                    return {\n                        val: {\n                            type: TYPE.select,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n                else {\n                    return {\n                        val: {\n                            type: TYPE.plural,\n                            value: value,\n                            options: fromEntries(optionsResult.val),\n                            offset: pluralOffset,\n                            pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                            location: location_2,\n                        },\n                        err: null,\n                    };\n                }\n            }\n            default:\n                return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n        }\n    };\n    Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n        // Parse: {value, number, ::currency/GBP }\n        //\n        if (this.isEOF() || this.char() !== 125 /* `}` */) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n        }\n        this.bump(); // `}`\n        return { val: true, err: null };\n    };\n    /**\n     * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n     */\n    Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n        var nestedBraces = 0;\n        var startPosition = this.clonePosition();\n        while (!this.isEOF()) {\n            var ch = this.char();\n            switch (ch) {\n                case 39 /* `'` */: {\n                    // Treat apostrophe as quoting but include it in the style part.\n                    // Find the end of the quoted literal text.\n                    this.bump();\n                    var apostrophePosition = this.clonePosition();\n                    if (!this.bumpUntil(\"'\")) {\n                        return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n                    }\n                    this.bump();\n                    break;\n                }\n                case 123 /* `{` */: {\n                    nestedBraces += 1;\n                    this.bump();\n                    break;\n                }\n                case 125 /* `}` */: {\n                    if (nestedBraces > 0) {\n                        nestedBraces -= 1;\n                    }\n                    else {\n                        return {\n                            val: this.message.slice(startPosition.offset, this.offset()),\n                            err: null,\n                        };\n                    }\n                    break;\n                }\n                default:\n                    this.bump();\n                    break;\n            }\n        }\n        return {\n            val: this.message.slice(startPosition.offset, this.offset()),\n            err: null,\n        };\n    };\n    Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n        var tokens = [];\n        try {\n            tokens = parseNumberSkeletonFromString(skeleton);\n        }\n        catch (e) {\n            return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n        }\n        return {\n            val: {\n                type: SKELETON_TYPE.number,\n                tokens: tokens,\n                location: location,\n                parsedOptions: this.shouldParseSkeletons\n                    ? parseNumberSkeleton(tokens)\n                    : {},\n            },\n            err: null,\n        };\n    };\n    /**\n     * @param nesting_level The current nesting level of messages.\n     *     This can be positive when parsing message fragment in select or plural argument options.\n     * @param parent_arg_type The parent argument's type.\n     * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n     *     the argument. It is a by-product of a previous parsing attempt.\n     * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n     *     between a pair of opening and closing tags. The nested message will not parse beyond\n     *     the closing tag boundary.\n     */\n    Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n        var _a;\n        var hasOtherClause = false;\n        var options = [];\n        var parsedSelectors = new Set();\n        var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;\n        // Parse:\n        // one {one apple}\n        // ^--^\n        while (true) {\n            if (selector.length === 0) {\n                var startPosition = this.clonePosition();\n                if (parentArgType !== 'select' && this.bumpIf('=')) {\n                    // Try parse `={number}` selector\n                    var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n                    if (result.err) {\n                        return result;\n                    }\n                    selectorLocation = createLocation(startPosition, this.clonePosition());\n                    selector = this.message.slice(startPosition.offset, this.offset());\n                }\n                else {\n                    break;\n                }\n            }\n            // Duplicate selector clauses\n            if (parsedSelectors.has(selector)) {\n                return this.error(parentArgType === 'select'\n                    ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR\n                    : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n            }\n            if (selector === 'other') {\n                hasOtherClause = true;\n            }\n            // Parse:\n            // one {one apple}\n            //     ^----------^\n            this.bumpSpace();\n            var openingBracePosition = this.clonePosition();\n            if (!this.bumpIf('{')) {\n                return this.error(parentArgType === 'select'\n                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\n                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n            var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n            if (fragmentResult.err) {\n                return fragmentResult;\n            }\n            var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n            if (argCloseResult.err) {\n                return argCloseResult;\n            }\n            options.push([\n                selector,\n                {\n                    value: fragmentResult.val,\n                    location: createLocation(openingBracePosition, this.clonePosition()),\n                },\n            ]);\n            // Keep track of the existing selectors\n            parsedSelectors.add(selector);\n            // Prep next selector clause.\n            this.bumpSpace();\n            (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);\n        }\n        if (options.length === 0) {\n            return this.error(parentArgType === 'select'\n                ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR\n                : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        if (this.requiresOtherClause && !hasOtherClause) {\n            return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n        return { val: options, err: null };\n    };\n    Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n        var sign = 1;\n        var startingPosition = this.clonePosition();\n        if (this.bumpIf('+')) {\n        }\n        else if (this.bumpIf('-')) {\n            sign = -1;\n        }\n        var hasDigits = false;\n        var decimal = 0;\n        while (!this.isEOF()) {\n            var ch = this.char();\n            if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {\n                hasDigits = true;\n                decimal = decimal * 10 + (ch - 48);\n                this.bump();\n            }\n            else {\n                break;\n            }\n        }\n        var location = createLocation(startingPosition, this.clonePosition());\n        if (!hasDigits) {\n            return this.error(expectNumberError, location);\n        }\n        decimal *= sign;\n        if (!isSafeInteger(decimal)) {\n            return this.error(invalidNumberError, location);\n        }\n        return { val: decimal, err: null };\n    };\n    Parser.prototype.offset = function () {\n        return this.position.offset;\n    };\n    Parser.prototype.isEOF = function () {\n        return this.offset() === this.message.length;\n    };\n    Parser.prototype.clonePosition = function () {\n        // This is much faster than `Object.assign` or spread.\n        return {\n            offset: this.position.offset,\n            line: this.position.line,\n            column: this.position.column,\n        };\n    };\n    /**\n     * Return the code point at the current position of the parser.\n     * Throws if the index is out of bound.\n     */\n    Parser.prototype.char = function () {\n        var offset = this.position.offset;\n        if (offset >= this.message.length) {\n            throw Error('out of bound');\n        }\n        var code = codePointAt(this.message, offset);\n        if (code === undefined) {\n            throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n        }\n        return code;\n    };\n    Parser.prototype.error = function (kind, location) {\n        return {\n            val: null,\n            err: {\n                kind: kind,\n                message: this.message,\n                location: location,\n            },\n        };\n    };\n    /** Bump the parser to the next UTF-16 code unit. */\n    Parser.prototype.bump = function () {\n        if (this.isEOF()) {\n            return;\n        }\n        var code = this.char();\n        if (code === 10 /* '\\n' */) {\n            this.position.line += 1;\n            this.position.column = 1;\n            this.position.offset += 1;\n        }\n        else {\n            this.position.column += 1;\n            // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n            this.position.offset += code < 0x10000 ? 1 : 2;\n        }\n    };\n    /**\n     * If the substring starting at the current position of the parser has\n     * the given prefix, then bump the parser to the character immediately\n     * following the prefix and return true. Otherwise, don't bump the parser\n     * and return false.\n     */\n    Parser.prototype.bumpIf = function (prefix) {\n        if (startsWith(this.message, prefix, this.offset())) {\n            for (var i = 0; i < prefix.length; i++) {\n                this.bump();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Bump the parser until the pattern character is found and return `true`.\n     * Otherwise bump to the end of the file and return `false`.\n     */\n    Parser.prototype.bumpUntil = function (pattern) {\n        var currentOffset = this.offset();\n        var index = this.message.indexOf(pattern, currentOffset);\n        if (index >= 0) {\n            this.bumpTo(index);\n            return true;\n        }\n        else {\n            this.bumpTo(this.message.length);\n            return false;\n        }\n    };\n    /**\n     * Bump the parser to the target offset.\n     * If target offset is beyond the end of the input, bump the parser to the end of the input.\n     */\n    Parser.prototype.bumpTo = function (targetOffset) {\n        if (this.offset() > targetOffset) {\n            throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n        }\n        targetOffset = Math.min(targetOffset, this.message.length);\n        while (true) {\n            var offset = this.offset();\n            if (offset === targetOffset) {\n                break;\n            }\n            if (offset > targetOffset) {\n                throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n            }\n            this.bump();\n            if (this.isEOF()) {\n                break;\n            }\n        }\n    };\n    /** advance the parser through all whitespace to the next non-whitespace code unit. */\n    Parser.prototype.bumpSpace = function () {\n        while (!this.isEOF() && _isWhiteSpace(this.char())) {\n            this.bump();\n        }\n    };\n    /**\n     * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n     * If the input has been exhausted, then this returns null.\n     */\n    Parser.prototype.peek = function () {\n        if (this.isEOF()) {\n            return null;\n        }\n        var code = this.char();\n        var offset = this.offset();\n        var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n        return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n    };\n    return Parser;\n}());\nexport { Parser };\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\nfunction _isAlpha(codepoint) {\n    return ((codepoint >= 97 && codepoint <= 122) ||\n        (codepoint >= 65 && codepoint <= 90));\n}\nfunction _isAlphaOrSlash(codepoint) {\n    return _isAlpha(codepoint) || codepoint === 47; /* '/' */\n}\n/** See `parseTag` function docs. */\nfunction _isPotentialElementNameChar(c) {\n    return (c === 45 /* '-' */ ||\n        c === 46 /* '.' */ ||\n        (c >= 48 && c <= 57) /* 0..9 */ ||\n        c === 95 /* '_' */ ||\n        (c >= 97 && c <= 122) /** a..z */ ||\n        (c >= 65 && c <= 90) /* A..Z */ ||\n        c == 0xb7 ||\n        (c >= 0xc0 && c <= 0xd6) ||\n        (c >= 0xd8 && c <= 0xf6) ||\n        (c >= 0xf8 && c <= 0x37d) ||\n        (c >= 0x37f && c <= 0x1fff) ||\n        (c >= 0x200c && c <= 0x200d) ||\n        (c >= 0x203f && c <= 0x2040) ||\n        (c >= 0x2070 && c <= 0x218f) ||\n        (c >= 0x2c00 && c <= 0x2fef) ||\n        (c >= 0x3001 && c <= 0xd7ff) ||\n        (c >= 0xf900 && c <= 0xfdcf) ||\n        (c >= 0xfdf0 && c <= 0xfffd) ||\n        (c >= 0x10000 && c <= 0xeffff));\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isWhiteSpace(c) {\n    return ((c >= 0x0009 && c <= 0x000d) ||\n        c === 0x0020 ||\n        c === 0x0085 ||\n        (c >= 0x200e && c <= 0x200f) ||\n        c === 0x2028 ||\n        c === 0x2029);\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\nfunction _isPatternSyntax(c) {\n    return ((c >= 0x0021 && c <= 0x0023) ||\n        c === 0x0024 ||\n        (c >= 0x0025 && c <= 0x0027) ||\n        c === 0x0028 ||\n        c === 0x0029 ||\n        c === 0x002a ||\n        c === 0x002b ||\n        c === 0x002c ||\n        c === 0x002d ||\n        (c >= 0x002e && c <= 0x002f) ||\n        (c >= 0x003a && c <= 0x003b) ||\n        (c >= 0x003c && c <= 0x003e) ||\n        (c >= 0x003f && c <= 0x0040) ||\n        c === 0x005b ||\n        c === 0x005c ||\n        c === 0x005d ||\n        c === 0x005e ||\n        c === 0x0060 ||\n        c === 0x007b ||\n        c === 0x007c ||\n        c === 0x007d ||\n        c === 0x007e ||\n        c === 0x00a1 ||\n        (c >= 0x00a2 && c <= 0x00a5) ||\n        c === 0x00a6 ||\n        c === 0x00a7 ||\n        c === 0x00a9 ||\n        c === 0x00ab ||\n        c === 0x00ac ||\n        c === 0x00ae ||\n        c === 0x00b0 ||\n        c === 0x00b1 ||\n        c === 0x00b6 ||\n        c === 0x00bb ||\n        c === 0x00bf ||\n        c === 0x00d7 ||\n        c === 0x00f7 ||\n        (c >= 0x2010 && c <= 0x2015) ||\n        (c >= 0x2016 && c <= 0x2017) ||\n        c === 0x2018 ||\n        c === 0x2019 ||\n        c === 0x201a ||\n        (c >= 0x201b && c <= 0x201c) ||\n        c === 0x201d ||\n        c === 0x201e ||\n        c === 0x201f ||\n        (c >= 0x2020 && c <= 0x2027) ||\n        (c >= 0x2030 && c <= 0x2038) ||\n        c === 0x2039 ||\n        c === 0x203a ||\n        (c >= 0x203b && c <= 0x203e) ||\n        (c >= 0x2041 && c <= 0x2043) ||\n        c === 0x2044 ||\n        c === 0x2045 ||\n        c === 0x2046 ||\n        (c >= 0x2047 && c <= 0x2051) ||\n        c === 0x2052 ||\n        c === 0x2053 ||\n        (c >= 0x2055 && c <= 0x205e) ||\n        (c >= 0x2190 && c <= 0x2194) ||\n        (c >= 0x2195 && c <= 0x2199) ||\n        (c >= 0x219a && c <= 0x219b) ||\n        (c >= 0x219c && c <= 0x219f) ||\n        c === 0x21a0 ||\n        (c >= 0x21a1 && c <= 0x21a2) ||\n        c === 0x21a3 ||\n        (c >= 0x21a4 && c <= 0x21a5) ||\n        c === 0x21a6 ||\n        (c >= 0x21a7 && c <= 0x21ad) ||\n        c === 0x21ae ||\n        (c >= 0x21af && c <= 0x21cd) ||\n        (c >= 0x21ce && c <= 0x21cf) ||\n        (c >= 0x21d0 && c <= 0x21d1) ||\n        c === 0x21d2 ||\n        c === 0x21d3 ||\n        c === 0x21d4 ||\n        (c >= 0x21d5 && c <= 0x21f3) ||\n        (c >= 0x21f4 && c <= 0x22ff) ||\n        (c >= 0x2300 && c <= 0x2307) ||\n        c === 0x2308 ||\n        c === 0x2309 ||\n        c === 0x230a ||\n        c === 0x230b ||\n        (c >= 0x230c && c <= 0x231f) ||\n        (c >= 0x2320 && c <= 0x2321) ||\n        (c >= 0x2322 && c <= 0x2328) ||\n        c === 0x2329 ||\n        c === 0x232a ||\n        (c >= 0x232b && c <= 0x237b) ||\n        c === 0x237c ||\n        (c >= 0x237d && c <= 0x239a) ||\n        (c >= 0x239b && c <= 0x23b3) ||\n        (c >= 0x23b4 && c <= 0x23db) ||\n        (c >= 0x23dc && c <= 0x23e1) ||\n        (c >= 0x23e2 && c <= 0x2426) ||\n        (c >= 0x2427 && c <= 0x243f) ||\n        (c >= 0x2440 && c <= 0x244a) ||\n        (c >= 0x244b && c <= 0x245f) ||\n        (c >= 0x2500 && c <= 0x25b6) ||\n        c === 0x25b7 ||\n        (c >= 0x25b8 && c <= 0x25c0) ||\n        c === 0x25c1 ||\n        (c >= 0x25c2 && c <= 0x25f7) ||\n        (c >= 0x25f8 && c <= 0x25ff) ||\n        (c >= 0x2600 && c <= 0x266e) ||\n        c === 0x266f ||\n        (c >= 0x2670 && c <= 0x2767) ||\n        c === 0x2768 ||\n        c === 0x2769 ||\n        c === 0x276a ||\n        c === 0x276b ||\n        c === 0x276c ||\n        c === 0x276d ||\n        c === 0x276e ||\n        c === 0x276f ||\n        c === 0x2770 ||\n        c === 0x2771 ||\n        c === 0x2772 ||\n        c === 0x2773 ||\n        c === 0x2774 ||\n        c === 0x2775 ||\n        (c >= 0x2794 && c <= 0x27bf) ||\n        (c >= 0x27c0 && c <= 0x27c4) ||\n        c === 0x27c5 ||\n        c === 0x27c6 ||\n        (c >= 0x27c7 && c <= 0x27e5) ||\n        c === 0x27e6 ||\n        c === 0x27e7 ||\n        c === 0x27e8 ||\n        c === 0x27e9 ||\n        c === 0x27ea ||\n        c === 0x27eb ||\n        c === 0x27ec ||\n        c === 0x27ed ||\n        c === 0x27ee ||\n        c === 0x27ef ||\n        (c >= 0x27f0 && c <= 0x27ff) ||\n        (c >= 0x2800 && c <= 0x28ff) ||\n        (c >= 0x2900 && c <= 0x2982) ||\n        c === 0x2983 ||\n        c === 0x2984 ||\n        c === 0x2985 ||\n        c === 0x2986 ||\n        c === 0x2987 ||\n        c === 0x2988 ||\n        c === 0x2989 ||\n        c === 0x298a ||\n        c === 0x298b ||\n        c === 0x298c ||\n        c === 0x298d ||\n        c === 0x298e ||\n        c === 0x298f ||\n        c === 0x2990 ||\n        c === 0x2991 ||\n        c === 0x2992 ||\n        c === 0x2993 ||\n        c === 0x2994 ||\n        c === 0x2995 ||\n        c === 0x2996 ||\n        c === 0x2997 ||\n        c === 0x2998 ||\n        (c >= 0x2999 && c <= 0x29d7) ||\n        c === 0x29d8 ||\n        c === 0x29d9 ||\n        c === 0x29da ||\n        c === 0x29db ||\n        (c >= 0x29dc && c <= 0x29fb) ||\n        c === 0x29fc ||\n        c === 0x29fd ||\n        (c >= 0x29fe && c <= 0x2aff) ||\n        (c >= 0x2b00 && c <= 0x2b2f) ||\n        (c >= 0x2b30 && c <= 0x2b44) ||\n        (c >= 0x2b45 && c <= 0x2b46) ||\n        (c >= 0x2b47 && c <= 0x2b4c) ||\n        (c >= 0x2b4d && c <= 0x2b73) ||\n        (c >= 0x2b74 && c <= 0x2b75) ||\n        (c >= 0x2b76 && c <= 0x2b95) ||\n        c === 0x2b96 ||\n        (c >= 0x2b97 && c <= 0x2bff) ||\n        (c >= 0x2e00 && c <= 0x2e01) ||\n        c === 0x2e02 ||\n        c === 0x2e03 ||\n        c === 0x2e04 ||\n        c === 0x2e05 ||\n        (c >= 0x2e06 && c <= 0x2e08) ||\n        c === 0x2e09 ||\n        c === 0x2e0a ||\n        c === 0x2e0b ||\n        c === 0x2e0c ||\n        c === 0x2e0d ||\n        (c >= 0x2e0e && c <= 0x2e16) ||\n        c === 0x2e17 ||\n        (c >= 0x2e18 && c <= 0x2e19) ||\n        c === 0x2e1a ||\n        c === 0x2e1b ||\n        c === 0x2e1c ||\n        c === 0x2e1d ||\n        (c >= 0x2e1e && c <= 0x2e1f) ||\n        c === 0x2e20 ||\n        c === 0x2e21 ||\n        c === 0x2e22 ||\n        c === 0x2e23 ||\n        c === 0x2e24 ||\n        c === 0x2e25 ||\n        c === 0x2e26 ||\n        c === 0x2e27 ||\n        c === 0x2e28 ||\n        c === 0x2e29 ||\n        (c >= 0x2e2a && c <= 0x2e2e) ||\n        c === 0x2e2f ||\n        (c >= 0x2e30 && c <= 0x2e39) ||\n        (c >= 0x2e3a && c <= 0x2e3b) ||\n        (c >= 0x2e3c && c <= 0x2e3f) ||\n        c === 0x2e40 ||\n        c === 0x2e41 ||\n        c === 0x2e42 ||\n        (c >= 0x2e43 && c <= 0x2e4f) ||\n        (c >= 0x2e50 && c <= 0x2e51) ||\n        c === 0x2e52 ||\n        (c >= 0x2e53 && c <= 0x2e7f) ||\n        (c >= 0x3001 && c <= 0x3003) ||\n        c === 0x3008 ||\n        c === 0x3009 ||\n        c === 0x300a ||\n        c === 0x300b ||\n        c === 0x300c ||\n        c === 0x300d ||\n        c === 0x300e ||\n        c === 0x300f ||\n        c === 0x3010 ||\n        c === 0x3011 ||\n        (c >= 0x3012 && c <= 0x3013) ||\n        c === 0x3014 ||\n        c === 0x3015 ||\n        c === 0x3016 ||\n        c === 0x3017 ||\n        c === 0x3018 ||\n        c === 0x3019 ||\n        c === 0x301a ||\n        c === 0x301b ||\n        c === 0x301c ||\n        c === 0x301d ||\n        (c >= 0x301e && c <= 0x301f) ||\n        c === 0x3020 ||\n        c === 0x3030 ||\n        c === 0xfd3e ||\n        c === 0xfd3f ||\n        (c >= 0xfe45 && c <= 0xfe46));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}