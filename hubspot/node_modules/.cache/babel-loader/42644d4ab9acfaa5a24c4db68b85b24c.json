{"ast":null,"code":"import { useRef as $eCAIO$useRef, useEffect as $eCAIO$useEffect, useMemo as $eCAIO$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $eCAIO$getFocusableTreeWalker, focusSafely as $eCAIO$focusSafely } from \"@react-aria/focus\";\nimport { focusWithoutScrolling as $eCAIO$focusWithoutScrolling, useEvent as $eCAIO$useEvent, scrollIntoView as $eCAIO$scrollIntoView, mergeProps as $eCAIO$mergeProps, isAppleDevice as $eCAIO$isAppleDevice, isMac as $eCAIO$isMac } from \"@react-aria/utils\";\nimport { useLocale as $eCAIO$useLocale, useCollator as $eCAIO$useCollator } from \"@react-aria/i18n\";\nimport { usePress as $eCAIO$usePress, useLongPress as $eCAIO$useLongPress } from \"@react-aria/interactions\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $ae20dd8cbca75726$exports = {};\n$parcel$export($ae20dd8cbca75726$exports, \"useSelectableCollection\", () => $ae20dd8cbca75726$export$d6daf82dcd84e87c);\n\nfunction $feb5ffebff200149$export$d3e3bd3e26688c04(e) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return $eCAIO$isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nfunction $feb5ffebff200149$export$16792effe837dba3(e) {\n  if ($eCAIO$isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\n\nvar $fb3050f43d946246$exports = {};\n$parcel$export($fb3050f43d946246$exports, \"useTypeSelect\", () => $fb3050f43d946246$export$e32c88dfddc6e1d8);\n\nfunction $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {\n  let {\n    keyboardDelegate: keyboardDelegate,\n    selectionManager: selectionManager,\n    onTypeSelect: onTypeSelect\n  } = options;\n  let state = $eCAIO$useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = e => {\n    let character = $fb3050f43d946246$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) return; // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) e.stopPropagation();\n    }\n\n    state.search += character; // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.\n\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction $fb3050f43d946246$var$getStringForKey(key) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return '';\n}\n\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref: ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized: isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {\n    direction: direction\n  } = $eCAIO$useLocale();\n\n  let onKeyDown = e => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') e.preventDefault(); // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n\n    if (!ref.current.contains(e.target)) return;\n\n    const navigateToKey = (key, childFocus) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n        if (e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(key);else if (selectOnFocus && !$feb5ffebff200149$export$d3e3bd3e26688c04(e)) manager.replaceSelection(key);\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown':\n        if (delegate.getKeyBelow) {\n          var ref4, ref1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (ref4 = delegate.getFirstKey) === null || ref4 === void 0 ? void 0 : ref4.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (ref1 = delegate.getFirstKey) === null || ref1 === void 0 ? void 0 : ref1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case 'ArrowUp':\n        if (delegate.getKeyAbove) {\n          var ref2, ref3;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (ref2 = delegate.getLastKey) === null || ref2 === void 0 ? void 0 : ref2.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (ref3 = delegate.getLastKey) === null || ref3 === void 0 ? void 0 : ref3.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n\n        break;\n\n      case 'ArrowRight':\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n\n        break;\n\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, $feb5ffebff200149$export$16792effe837dba3(e));\n          manager.setFocusedKey(firstKey);\n          if ($feb5ffebff200149$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n\n        break;\n\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, $feb5ffebff200149$export$16792effe837dba3(e));\n          manager.setFocusedKey(lastKey);\n          if ($feb5ffebff200149$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n\n        break;\n\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case 'a':\n        if ($feb5ffebff200149$export$16792effe837dba3(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n\n        break;\n\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n\n      case 'Tab':\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            let walker = $eCAIO$getFocusableTreeWalker(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) $eCAIO$focusWithoutScrolling(next);\n          }\n          break;\n        }\n\n    }\n  }; // Store the scroll position so we can restore it later.\n\n\n  let scrollPos = $eCAIO$useRef({\n    top: 0,\n    left: 0\n  });\n  $eCAIO$useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    } // Focus events can bubble through portals. Ignore these events.\n\n\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = key => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      }; // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n\n\n      let relatedTarget = e.relatedTarget;\n\n      var _lastSelectedKey, _firstSelectedKey;\n\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_lastSelectedKey = manager.lastSelectedKey) !== null && _lastSelectedKey !== void 0 ? _lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_firstSelectedKey = manager.firstSelectedKey) !== null && _firstSelectedKey !== void 0 ? _firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left; // Refocus and scroll the focused item into view if it exists within the scrollable region.\n\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        $eCAIO$focusWithoutScrolling(element);\n        $eCAIO$scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n\n  const autoFocusRef = $eCAIO$useRef(autoFocus);\n  $eCAIO$useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null; // Check focus strategy to determine which item to focus\n\n      if (autoFocus === 'first') focusedKey = delegate.getFirstKey();\n      if (autoFocus === 'last') focusedKey = delegate.getLastKey(); // If there are any selected keys, make the first one the new focus target\n\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.\n\n      if (focusedKey == null && !shouldUseVirtualFocus) $eCAIO$focusSafely(ref.current);\n    }\n\n    autoFocusRef.current = false; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n\n  $eCAIO$useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`);\n      if (element) $eCAIO$scrollIntoView(scrollRef.current, element);\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n  let handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n\n  };\n  let {\n    typeSelectProps: typeSelectProps\n  } = $fb3050f43d946246$export$e32c88dfddc6e1d8({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n  if (!disallowTypeAhead) handlers = $eCAIO$mergeProps(typeSelectProps, handlers); // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n\n  let tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: { ...handlers,\n      tabIndex: tabIndex\n    }\n  };\n}\n\nvar $880e95eb8b93ba9a$exports = {};\n$parcel$export($880e95eb8b93ba9a$exports, \"useSelectableItem\", () => $880e95eb8b93ba9a$export$ecf600387e221c37);\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  let {\n    selectionManager: manager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    isVirtualized: isVirtualized,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    focus: focus,\n    isDisabled: isDisabled,\n    onAction: onAction,\n    allowsDifferentPressOrigin: allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = e => {\n    if (e.pointerType === 'keyboard' && $feb5ffebff200149$export$d3e3bd3e26688c04(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === 'none') return;\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === 'toggle' || e && ($feb5ffebff200149$export$16792effe837dba3(e) || e.pointerType === 'touch' || e.pointerType === 'virtual')) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  }; // Focus the associated DOM node when this item becomes the focusedKey\n\n\n  $eCAIO$useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) focus();else $eCAIO$focusSafely(ref.current);\n    }\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n\n  let itemProps = {};\n  if (!shouldUseVirtualFocus) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n\n    onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n\n  }; // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === 'replace' ? !allowsSelection : manager.isEmpty);\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = $eCAIO$useRef(null);\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = $eCAIO$useRef(false);\n  let hadPrimaryActionOnPressStart = $eCAIO$useRef(false); // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n\n  let itemPressProps = {};\n\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    }; // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n\n\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = e => {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== 'mouse') {\n        if (e.pointerType === 'keyboard' && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        onAction();\n      } else if (e.pointerType !== 'keyboard') onSelect(e);\n    };else {\n      itemPressProps.onPressUp = e => {\n        if (e.pointerType !== 'keyboard') onSelect(e);\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction; // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n\n      if (e.pointerType === 'mouse' && !hasPrimaryAction || e.pointerType === 'keyboard' && (!onAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n\n    itemPressProps.onPress = e => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'virtual' || e.pointerType === 'keyboard' && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) onAction();else onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = $eCAIO$usePress(itemPressProps); // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n\n  let onDoubleClick = hasSecondaryAction ? e => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined; // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n\n  let {\n    longPressProps: longPressProps\n  } = $eCAIO$useLongPress({\n    isDisabled: !longPressEnabled,\n\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n\n  }); // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n\n  let onDragStart = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n\n  return {\n    itemProps: $eCAIO$mergeProps(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStart: onDragStart\n    }),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\n\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === 'Enter';\n}\n\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === ' ' || (event === null || event === void 0 ? void 0 : event.code) === 'Space';\n}\n\nvar $982254629710d113$exports = {};\n$parcel$export($982254629710d113$exports, \"useSelectableList\", () => $982254629710d113$export$b95089534ab7c1fd);\nvar $2a25aae57d74318e$exports = {};\n$parcel$export($2a25aae57d74318e$exports, \"ListKeyboardDelegate\", () => $2a25aae57d74318e$export$a05409b8bb224a5a);\n\nclass $2a25aae57d74318e$export$a05409b8bb224a5a {\n  getKeyBelow(key) {\n    key = this.collection.getKeyAfter(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key) {\n    key = this.collection.getKeyBefore(key);\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getItem(key) {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) return null;\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n\n  constructor(collection, disabledKeys, ref, collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n}\n\nfunction $982254629710d113$export$b95089534ab7c1fd(props) {\n  let {\n    selectionManager: selectionManager,\n    collection: collection,\n    disabledKeys: disabledKeys,\n    ref: ref,\n    keyboardDelegate: keyboardDelegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    isVirtualized: isVirtualized,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation\n  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  let collator = $eCAIO$useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  let delegate = $eCAIO$useMemo(() => keyboardDelegate || new $2a25aae57d74318e$export$a05409b8bb224a5a(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n  let {\n    collectionProps: collectionProps\n  } = $ae20dd8cbca75726$export$d6daf82dcd84e87c({\n    ref: ref,\n    selectionManager: selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus: selectOnFocus,\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation,\n    isVirtualized: isVirtualized,\n    scrollRef: ref\n  });\n  return {\n    listProps: collectionProps\n  };\n}\n\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection, $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem, $982254629710d113$export$b95089534ab7c1fd as useSelectableList, $2a25aae57d74318e$export$a05409b8bb224a5a as ListKeyboardDelegate, $fb3050f43d946246$export$e32c88dfddc6e1d8 as useTypeSelect };","map":{"version":3,"mappings":"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","names":["$feb5ffebff200149$export$d3e3bd3e26688c04","e","$eCAIO$isAppleDevice","altKey","ctrlKey","$feb5ffebff200149$export$16792effe837dba3","$eCAIO$isMac","metaKey","$fb3050f43d946246$export$e32c88dfddc6e1d8","options","keyboardDelegate","selectionManager","onTypeSelect","state","$eCAIO$useRef","search","timeout","current","onKeyDown","character","$fb3050f43d946246$var$getStringForKey","key","trim","length","preventDefault","stopPropagation","getKeyForSearch","focusedKey","setFocusedKey","clearTimeout","setTimeout","typeSelectProps","onKeyDownCapture","test","$ae20dd8cbca75726$export$d6daf82dcd84e87c","manager","delegate","ref","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","selectionBehavior","disallowTypeAhead","shouldUseVirtualFocus","allowsTabNavigation","isVirtualized","scrollRef","direction","$eCAIO$useLocale","contains","target","navigateToKey","childFocus","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","ref4","ref1","nextKey","getFirstKey","call","getKeyAbove","ref2","ref3","getLastKey","getKeyLeftOf","getKeyRightOf","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","clearSelection","focus","walker","$eCAIO$getFocusableTreeWalker","tabbable","next","last","lastChild","document","activeElement","$eCAIO$focusWithoutScrolling","scrollPos","top","left","$eCAIO$useEvent","scrollTop","scrollLeft","onFocus","isFocused","currentTarget","setFocused","navigateToFirstKey","relatedTarget","_lastSelectedKey","_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","querySelector","$eCAIO$scrollIntoView","onBlur","autoFocusRef","$eCAIO$useEffect","selectedKeys","size","values","value","$eCAIO$focusSafely","handlers","onMouseDown","$eCAIO$mergeProps","tabIndex","collectionProps","$880e95eb8b93ba9a$export$ecf600387e221c37","shouldSelectOnPressUp","isDisabled","onAction","allowsDifferentPressOrigin","onSelect","pointerType","toggleSelection","isSelected","childFocusStrategy","itemProps","allowsSelection","canSelectItem","allowsActions","hasPrimaryAction","isEmpty","hasSecondaryAction","hasAction","modality","longPressEnabled","longPressEnabledOnPressStart","hadPrimaryActionOnPressStart","itemPressProps","onPressStart","$880e95eb8b93ba9a$var$isSelectionKey","onPress","$880e95eb8b93ba9a$var$isActionKey","onPressUp","preventFocusOnPress","pressProps","isPressed","$eCAIO$usePress","onDoubleClick","undefined","longPressProps","$eCAIO$useLongPress","onLongPress","setSelectionBehavior","onDragStart","event","window","code","$2a25aae57d74318e$export$a05409b8bb224a5a","collection","getKeyAfter","item","getItem","type","disabledKeys","has","getKeyBefore","menu","pageY","Math","max","offsetTop","offsetHeight","min","scrollHeight","fromKey","collator","substring","textValue","slice","compare","$982254629710d113$export$b95089534ab7c1fd","props","$eCAIO$useCollator","usage","sensitivity","$eCAIO$useMemo","listProps"],"sources":["C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\utils.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useTypeSelect.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableCollection.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableItem.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\ListKeyboardDelegate.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-aria\\selection\\dist\\packages\\@react-aria\\selection\\src\\useSelectableList.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: HTMLElement;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect, useRef} from 'react';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {LongPressEvent, PressEvent} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  isDisabled = isDisabled || manager.isDisabled(key);\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          onAction();\n        } else if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = (e) => {\n        if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n        (e.pointerType === 'keyboard' && (!onAction || isSelectionKey()))\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  let onDragStart = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStart}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}