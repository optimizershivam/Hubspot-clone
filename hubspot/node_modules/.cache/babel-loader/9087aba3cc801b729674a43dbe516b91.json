{"ast":null,"code":"import { useState as $8D3nr$useState, useMemo as $8D3nr$useMemo, useEffect as $8D3nr$useEffect, useCallback as $8D3nr$useCallback } from \"react\";\nimport { useLayoutEffect as $8D3nr$useLayoutEffect } from \"@react-aria/utils\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $c74cda7d31af1253$exports = {};\n$parcel$export($c74cda7d31af1253$exports, \"Layout\", () => $c74cda7d31af1253$export$c84671f46d6a1ca);\n\nclass $c74cda7d31af1253$export$c84671f46d6a1ca {\n  /**\n  * Returns whether the layout should invalidate in response to\n  * visible rectangle changes. By default, it only invalidates\n  * when the collection view's size changes. Return true always\n  * to make the layout invalidate while scrolling (e.g. sticky headers).\n  */\n  shouldInvalidate(newRect, oldRect) {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n  }\n  /**\n  * This method allows the layout to perform any pre-computation\n  * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n  * Called by the collection view before {@link getVisibleLayoutInfos}\n  * or {@link getLayoutInfo} are called.\n  */\n\n\n  validate(invalidationContext) {}\n  /**\n  * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n  * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n  * @param point The point at which the drag occurred.\n  */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n  * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n  * to reject the drop. The dropped items will be inserted before the resulting target.\n  * @param point The point at which the drop occurred.\n  */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n  * Returns the starting attributes for an animated insertion.\n  * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n  * The default implementation just returns its input.\n  *\n  * @param layoutInfo The proposed LayoutInfo for this view.\n  */\n\n\n  getInitialLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n  /**\n  * Returns the ending attributes for an animated removal.\n  * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n  * to the one returned by this method. The default implementation returns its input.\n  *\n  * @param layoutInfo The original LayoutInfo for this view.\n  */\n\n\n  getFinalLayoutInfo(layoutInfo) {\n    return layoutInfo;\n  }\n\n}\n\nvar $d7fd61009c21d0bb$exports = {};\n$parcel$export($d7fd61009c21d0bb$exports, \"LayoutInfo\", () => $d7fd61009c21d0bb$export$7e0eeb9da702a085);\n\nclass $d7fd61009c21d0bb$export$7e0eeb9da702a085 {\n  /**\n  * Returns a copy of the LayoutInfo.\n  */\n  copy() {\n    let res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n  /**\n  * @param type A string representing the view type. Should be `'item'` for item views.\n                          Other types are used by supplementary views.\n  * @param key The unique key for this view.\n  * @param rect The rectangle describing the size and position of this view.\n  */\n\n\n  constructor(type, key, rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n}\n\nvar $3041db3296945e6e$exports = {};\n$parcel$export($3041db3296945e6e$exports, \"Point\", () => $3041db3296945e6e$export$baf26146a414f24a);\n\nclass $3041db3296945e6e$export$baf26146a414f24a {\n  /**\n  * Returns a copy of this point.\n  */\n  copy() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n  }\n  /**\n  * Checks if two points are equal.\n  */\n\n\n  equals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n  /**\n  * Returns true if this point is the origin.\n  */\n\n\n  isOrigin() {\n    return this.x === 0 && this.y === 0;\n  }\n\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.x = x;\n    this.y = y;\n  }\n\n}\n\nvar $60423f92c7f9ad87$exports = {};\n$parcel$export($60423f92c7f9ad87$exports, \"Rect\", () => $60423f92c7f9ad87$export$c79fc6492f3af13d);\n\nclass $60423f92c7f9ad87$export$c79fc6492f3af13d {\n  /**\n  * The maximum x-coordinate in the rectangle.\n  */\n  get maxX() {\n    return this.x + this.width;\n  }\n  /**\n  * The maximum y-coordinate in the rectangle.\n  */\n\n\n  get maxY() {\n    return this.y + this.height;\n  }\n  /**\n  * The area of the rectangle.\n  */\n\n\n  get area() {\n    return this.width * this.height;\n  }\n  /**\n  * The top left corner of the rectangle.\n  */\n\n\n  get topLeft() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n  }\n  /**\n  * The top right corner of the rectangle.\n  */\n\n\n  get topRight() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.y);\n  }\n  /**\n  * The bottom left corner of the rectangle.\n  */\n\n\n  get bottomLeft() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.maxY);\n  }\n  /**\n  * The bottom right corner of the rectangle.\n  */\n\n\n  get bottomRight() {\n    return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.maxY);\n  }\n  /**\n  * Returns whether this rectangle intersects another rectangle.\n  * @param rect - The rectangle to check.\n  */\n\n\n  intersects(rect) {\n    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n  }\n  /**\n  * Returns whether this rectangle fully contains another rectangle.\n  * @param rect - The rectangle to check.\n  */\n\n\n  containsRect(rect) {\n    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n  }\n  /**\n  * Returns whether the rectangle contains the given point.\n  * @param point - The point to check.\n  */\n\n\n  containsPoint(point) {\n    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n  }\n  /**\n  * Returns the first corner of this rectangle (from top to bottom, left to right)\n  * that is contained in the given rectangle, or null of the rectangles do not intersect.\n  * @param rect - The rectangle to check.\n  */\n\n\n  getCornerInRect(rect) {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) return key;\n    }\n\n    return null;\n  }\n\n  equals(rect) {\n    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n\n  pointEquals(point) {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  sizeEquals(size) {\n    return this.width === size.width && this.height === size.height;\n  }\n  /**\n  * Returns a copy of this rectangle.\n  */\n\n\n  copy() {\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n  }\n\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n}\n\nvar $ee1bfa90a957fb8a$exports = {};\n$parcel$export($ee1bfa90a957fb8a$exports, \"Size\", () => $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n\nclass $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec {\n  /**\n  * Returns a copy of this size.\n  */\n  copy() {\n    return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n  }\n  /**\n  * Returns whether this size is equal to another one.\n  */\n\n\n  equals(other) {\n    return this.width === other.width && this.height === other.height;\n  }\n\n  constructor() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.width = width;\n    this.height = height;\n  }\n\n}\n\nvar $ad1d98aa8f0c31b4$exports = {};\n$parcel$export($ad1d98aa8f0c31b4$exports, \"ReusableView\", () => $ad1d98aa8f0c31b4$export$1a5223887c560441);\nlet $ad1d98aa8f0c31b4$var$KEY = 0;\n\nclass $ad1d98aa8f0c31b4$export$1a5223887c560441 {\n  /**\n  * Prepares the view for reuse. Called just before the view is removed from the DOM.\n  */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n\n  constructor(virtualizer) {\n    this.virtualizer = virtualizer;\n    this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n  }\n\n}\n\nvar $fc0b13b484ac1194$exports = {};\n$parcel$export($fc0b13b484ac1194$exports, \"useVirtualizerState\", () => $fc0b13b484ac1194$export$1505db82fe357e65); // use high res timer if available\n\nlet $3eb131dcf37ad5f8$var$perf = typeof window !== 'undefined' ? window.performance : null; // @ts-ignore\n\nlet $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nlet $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nlet $3eb131dcf37ad5f8$var$fixTs;\n\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n  let canceled = false;\n  let raf_id;\n  let promise = new Promise(resolve => {\n    let start = $3eb131dcf37ad5f8$var$getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1000000000000 !== $3eb131dcf37ad5f8$var$getTime() > 1000000000000;\n      if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime(); // check if we're done\n\n      let delta = t - start;\n\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new $3041db3296945e6e$export$baf26146a414f24a(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n      }\n    });\n  });\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n  return t;\n}\n\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\nfunction $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n  let res = new Set();\n\n  for (let key of a.keys()) if (!b.has(key)) res.add(key);\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n  let toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n  let toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n  let toUpdate = new Set();\n\n  for (let key of a.keys()) if (b.has(key)) toUpdate.add(key);\n\n  return {\n    toRemove: toRemove,\n    toAdd: toAdd,\n    toUpdate: toUpdate\n  };\n}\n\nfunction* $fc36f9a046a9ce79$export$cfc14088dfefce5f() {\n  for (var _len = arguments.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterators[_key] = arguments[_key];\n  }\n\n  for (let iterator of iterators) yield* iterator;\n}\n\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n  let res = {};\n\n  for (let key in object) res[object[key]] = key;\n\n  return res;\n}\n\nclass $364191b3decf3697$var$RollingAverage {\n  addSample(sample) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n\n  constructor() {\n    this.count = 0;\n    this.value = 0;\n  }\n\n}\n\nclass $364191b3decf3697$export$4455ee6afb38dcbb {\n  setVisibleRect(rect) {\n    let time = performance.now() - this.startTime;\n\n    if (time < 500) {\n      this.averageTime.addSample(time);\n      if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) this.averagePerf.addSample(time);\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n\n  constructor() {\n    this.startTime = 0;\n    this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n    this.averageTime = new $364191b3decf3697$var$RollingAverage();\n    this.velocity = new $3041db3296945e6e$export$baf26146a414f24a(5, 5);\n    this.overscanX = new $364191b3decf3697$var$RollingAverage();\n    this.overscanY = new $364191b3decf3697$var$RollingAverage();\n    this.visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n  }\n\n}\n\nclass $8e135e531d8dcb66$export$febc5573c75cefb0 {\n  constructor() {\n    this.level = 0;\n    this.actions = [];\n    this.animated = true;\n    this.initialMap = new Map();\n    this.finalMap = new Map();\n    this.initialLayoutInfo = new Map();\n    this.finalLayoutInfo = new Map();\n    this.removed = new Map();\n    this.toRemove = new Map();\n  }\n\n}\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset) {\n    let rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n  * Get the size of the scrollable content.\n  */\n\n\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n  * Get the collection view's currently visible rectangle.\n  */\n\n\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n  * Set the collection view's currently visible rectangle.\n  */\n\n\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let current = this._visibleRect; // Ignore if the rects are equal\n\n    if (rect.equals(current)) return;\n    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n\n    this._visibleRect = rect;\n    if (shouldInvalidate) this.relayout({\n      offsetChanged: !rect.pointEquals(current),\n      sizeChanged: !rect.sizeEquals(current)\n    });else this.updateSubviews(forceUpdate);\n  }\n\n  get collection() {\n    return this._collection;\n  }\n\n  set collection(data) {\n    this._setData(data);\n  }\n\n  _setData(data) {\n    if (data === this._collection) return;\n    if (this._collection) this._runTransaction(() => {\n      this._collection = data;\n    }, this.transitionDuration > 0);else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n  * Reloads the data from the data source and relayouts the collection view.\n  * Does not animate any changes. Equivalent to re-assigning the same data source\n  * to the collection view.\n  */\n\n\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n  * Returns the item with the given key.\n  */\n\n\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /**\n  * Get the collection view's layout.\n  */\n\n\n  get layout() {\n    return this._layout;\n  }\n  /**\n  * Set the collection view's layout.\n  */\n\n\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n  * Sets the collection view's layout, optionally with an animated transition\n  * from the current layout to the new layout.\n  * @param layout The layout to switch to.\n  * @param animated Whether to animate the layout change.\n  */\n\n\n  setLayout(layout) {\n    let animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (layout === this._layout) return;\n\n    let applyLayout = () => {\n      if (this._layout) // @ts-ignore\n        this._layout.virtualizer = null;\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {\n        type: type,\n        reuseType: reuseType\n      };\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n\n    let {\n      reuseType: reuseType\n    } = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new $ad1d98aa8f0c31b4$export$1a5223887c560441(this);\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n\n    return view;\n  }\n\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns an array of all currently visible views, including both\n  * item views and supplementary views.\n  */\n\n\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n  * Gets the visible view for the given type and key. Returns null if\n  * the view is not currently visible.\n  *\n  * @param key The key of the view to retrieve.\n  */\n\n\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n  * Returns an array of visible views matching the given type.\n  * @param type The view type to find.\n  */\n\n\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n  * Returns the key for the given view. Returns null\n  * if the view is not currently visible.\n  */\n\n\n  keyForView(view) {\n    if (view && view.layoutInfo) return view.layoutInfo.key;\n    return null;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n\n\n  keyAtPoint(point) {\n    let rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let layoutInfo = layoutInfos[0];\n    if (!layoutInfo) return null;\n    return layoutInfo.key;\n  }\n  /**\n  * Cleanup for when the Virtualizer will be unmounted.\n  */\n\n\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n  * Triggers a layout invalidation, and updates the visible subviews.\n  */\n\n\n  relayout() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') return; // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n  /**\n  * Performs a relayout immediately. Prefer {@link relayout} over this method\n  * where possible, since it coalesces multiple layout passes in the same tick.\n  */\n\n\n  relayoutNow() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {};\n\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null; // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n\n      context = { ...this._invalidationContext,\n        ...context\n      };\n    } // Reset the invalidation context\n\n\n    this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n\n    if (!this.layout || !this._collection || this._scrollAnimation) return;\n\n    let scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided\n\n\n    if (typeof context.beforeLayout === 'function') context.beforeLayout(); // Validate the layout\n\n    this.layout.validate(context);\n\n    this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n\n    if (typeof context.afterLayout === 'function') context.afterLayout(); // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n\n    let visibleRect = this.getVisibleRect();\n\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else this._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(contentOffsetX, contentOffsetY));\n    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged); // Apply layout infos, unless this is coming from an animated transaction\n\n\n    if (!(context.transaction && context.animated)) this._applyLayoutInfos(); // Wait for animations, and apply the afterAnimation hook, if provided\n\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x: x,\n            y: y\n          } = this.getVisibleRect();\n\n          this._resetAnimatedContentOffset();\n\n          this._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') context.afterAnimation();\n      }; // Sometimes the animation takes slightly longer than expected.\n\n\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') context.afterAnimation();\n  }\n  /**\n  * Corrects DOM order of visible views to match item order of collection.\n  */\n\n\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) return;\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n\n      this._children.delete(view);\n\n      this._children.add(view);\n    }\n  }\n\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) return null;\n    let visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    } // No need to anchor the scroll position if it is at the top\n\n\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null; // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n    let cornerAnchor = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      var ref;\n      let finalAnchor = ((ref = context.transaction) === null || ref === void 0 ? void 0 : ref.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  _getLayoutInfoMap(rect) {\n    let copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) layoutInfo = layoutInfo.copy();\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this._collection) return;\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd: toAdd,\n        toRemove: toRemove,\n        toUpdate: toUpdate\n      } = $fc36f9a046a9ce79$export$acaf96a27438246b(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) continue;\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) toUpdate.delete(key);else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType: reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      } // We are done if the sets are equal\n\n\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) this._applyLayoutInfos();\n        return;\n      }\n    } // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n\n\n    let removed = new Set();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n\n      if (view) {\n        removed.add(view);\n\n        this._visibleViews.delete(key); // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n\n\n        if (this._transaction) this._transaction.toRemove.set(key, view);else this.reuseView(view);\n      }\n    }\n\n    for (let key1 of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key1);\n      let view; // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key1)) layoutInfo = this._transaction.initialLayoutInfo.get(key1);\n        view = this._transaction.toRemove.get(key1);\n\n        if (view) {\n          this._transaction.toRemove.delete(key1);\n\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n        if (!removed.has(view)) this._children.add(view);\n      }\n\n      this._visibleViews.set(key1, view);\n\n      removed.delete(view);\n    }\n\n    for (let key2 of toUpdate) {\n      let view = currentlyVisible.get(key2);\n\n      this._renderedContent.delete(key2);\n\n      this._renderView(view);\n    } // Remove the remaining rows to delete from the DOM\n\n\n    if (!this._transaction) this.removeViews(removed);\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n\n    if (hasLayoutUpdates) requestAnimationFrame(() => {\n      // If we're in a transaction, apply animations to visible views\n      // and \"to be removed\" views, which animate off screen.\n      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());\n    });\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) this._overscanManager.collectMetrics();\n  }\n\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n\n    for (let view1 of this._children) {\n      if (!viewsByParentKey.has(view1.layoutInfo.parentKey)) viewsByParentKey.set(view1.layoutInfo.parentKey, []);\n      viewsByParentKey.get(view1.layoutInfo.parentKey).push(view1);\n      if (!viewsByParentKey.has(view1.layoutInfo.key)) viewsByParentKey.set(view1.layoutInfo.key, []);\n    }\n\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n\n    let children1 = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children1);\n  }\n\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) return false;\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  _applyLayoutInfos() {\n    let updated = false; // Apply layout infos to visible views\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n\n      if (cur) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    } // Apply final layout infos for views that will be removed\n\n\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n\n      for (let view2 of this._transaction.removed.values()) {\n        let cur = view2.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view2, layoutInfo)) updated = true;\n      }\n    }\n\n    if (updated) this._flushVisibleViews();\n  }\n\n  _hasLayoutUpdates() {\n    if (!this._transaction) return false;\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) return true;\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if ( // Uses equals rather than pointEquals so that width/height changes are taken into account\n      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n    }\n\n    return false;\n  }\n\n  reuseView(view) {\n    view.prepareForReuse();\n\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove) {\n    for (let view of toRemove) this._children.delete(view);\n  }\n\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) return; // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n\n      return;\n    } // @ts-ignore\n\n\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.relayout();\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n\n    this._correctItemOrder();\n\n    this._flushVisibleViews();\n  }\n\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n  * Scrolls the item with the given key into view, optionally with an animation.\n  * @param key The key of the item to scroll into view.\n  * @param duration The duration of the scroll animation.\n  */\n\n\n  scrollToItem(key, options) {\n    // key can be 0, so check if null or undefined\n    if (key == null) return;\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) return;\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n    }\n\n    return this.scrollTo(new $3041db3296945e6e$export$baf26146a414f24a(x, y), duration);\n  }\n  /**\n  * Performs an animated scroll to the given offset.\n  * @param offset - The offset to scroll to.\n  * @param duration The duration of the animation.\n  * @returns A promise that resolves when the animation is complete.\n  */\n\n\n  scrollTo(offset1) {\n    let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n\n      this._scrollAnimation = null;\n    } // Set the content offset synchronously if the duration is zero\n\n\n    if (duration <= 0 || this.visibleRect.pointEquals(offset1)) {\n      this._setContentOffset(offset1);\n\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n    this._scrollAnimation = $3eb131dcf37ad5f8$export$dc0b63720788090c(this.visibleRect, offset1, duration, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, offset => {\n      this._setContentOffset(offset);\n    });\n\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null; // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n\n      for (let [key, size] of this._sizeUpdateQueue) this.updateItemSize(key, size);\n\n      this._sizeUpdateQueue.clear();\n\n      this.relayout();\n\n      this._processTransactionQueue();\n\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  _runTransaction(action, animated) {\n    this._startTransaction();\n\n    if (this._nextTransaction) this._nextTransaction.actions.push(action);\n\n    this._endTransaction(animated);\n  }\n\n  _startTransaction() {\n    if (!this._nextTransaction) this._nextTransaction = new $8e135e531d8dcb66$export$febc5573c75cefb0();\n    this._nextTransaction.level++;\n  }\n\n  _endTransaction(animated) {\n    if (!this._nextTransaction) return false; // Save whether the transaction should be animated.\n\n    if (animated != null) this._nextTransaction.animated = animated; // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n\n    if (--this._nextTransaction.level > 0) return false; // Do nothing for empty transactions\n\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    } // Default animations to true\n\n\n    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true; // Enqueue the transaction\n\n    this._transactionQueue.push(this._nextTransaction);\n\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n\n    return true;\n  }\n\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) return;\n\n    let next = this._transactionQueue.shift();\n\n    if (next) this._performTransaction(next);\n  }\n\n  _getContentRect() {\n    return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true); // Apply the actions that occurred during this transaction\n\n        for (let action of transaction.actions) action();\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n\n          this._setupTransactionAnimations(transaction);\n        } else this._transaction = null;\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of $fc36f9a046a9ce79$export$cfc14088dfefce5f(transaction.toRemove.values(), transaction.removed.values())) {\n          this._children.delete(view);\n\n          this.reuseView(view);\n        }\n        this._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete\n\n        this._correctItemOrder();\n\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap: initialMap,\n      finalMap: finalMap\n    } = transaction; // Store initial and final layout infos for animations\n\n    for (let [key, layoutInfo] of initialMap) if (finalMap.has(key)) // Store the initial layout info for use during animations.\n      transaction.initialLayoutInfo.set(key, layoutInfo);else // This view was removed. Store the layout info for use\n      // in Layout#getFinalLayoutInfo during animations.\n      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo); // Get initial layout infos for views that were added\n\n\n    for (let [key3, layoutInfo1] of finalMap) if (!initialMap.has(key3)) {\n      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo1.copy());\n      transaction.initialLayoutInfo.set(key3, initialLayoutInfo);\n    } // Figure out which views were removed.\n\n\n    for (let [key4, view] of this._visibleViews) // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n    // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n    // added, removed... etc in a loop. The resize buffer (\"spooky column\") often has a width of 0.\n    if (!finalMap.has(key4) && view.layoutInfo.rect.width > 0) {\n      transaction.removed.set(key4, view);\n\n      this._visibleViews.delete(key4); // In case something weird happened, where we have a view but no\n      // initial layout info, use the one attached to the view.\n\n\n      if (view.layoutInfo) {\n        if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n      }\n    }\n  }\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._contentSize = new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec();\n    this._visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new $364191b3decf3697$export$4455ee6afb38dcbb();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    var _transitionDuration; // Set options from passed object if given\n\n\n    this.transitionDuration = (_transitionDuration = options.transitionDuration) !== null && _transitionDuration !== void 0 ? _transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n\n    for (let key of ['delegate', 'size', 'layout', 'collection']) if (options[key]) this[key] = options[key];\n  }\n\n}\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n  let [visibleViews, setVisibleViews] = $8D3nr$useState([]);\n  let [contentSize, setContentSize] = $8D3nr$useState(new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec());\n  let [isAnimating, setAnimating] = $8D3nr$useState(false);\n  let [isScrolling, setScrolling] = $8D3nr$useState(false);\n  let virtualizer = $8D3nr$useMemo(() => new $38b9490c1cca8fc4$export$89be5a243e59c4b2(), []);\n  virtualizer.delegate = {\n    setVisibleViews: setVisibleViews,\n\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n\n    setContentSize: setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  $8D3nr$useLayoutEffect(() => {\n    virtualizer.afterRender();\n  }); // eslint-disable-next-line arrow-body-style\n\n  $8D3nr$useEffect(() => {\n    return () => virtualizer.willUnmount();\n  }, []);\n  return {\n    virtualizer: virtualizer,\n    visibleViews: visibleViews,\n    setVisibleRect: $8D3nr$useCallback(rect => {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize: contentSize,\n    isAnimating: isAnimating,\n    isScrolling: isScrolling,\n    startScrolling: $8D3nr$useCallback(() => {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: $8D3nr$useCallback(() => {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n\nexport { $c74cda7d31af1253$export$c84671f46d6a1ca as Layout, $d7fd61009c21d0bb$export$7e0eeb9da702a085 as LayoutInfo, $3041db3296945e6e$export$baf26146a414f24a as Point, $60423f92c7f9ad87$export$c79fc6492f3af13d as Rect, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec as Size, $ad1d98aa8f0c31b4$export$1a5223887c560441 as ReusableView, $fc0b13b484ac1194$export$1505db82fe357e65 as useVirtualizerState };","map":{"version":3,"mappings":"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","names":["$c74cda7d31af1253$export$c84671f46d6a1ca","shouldInvalidate","newRect","oldRect","width","height","validate","invalidationContext","getInitialLayoutInfo","layoutInfo","getFinalLayoutInfo","$d7fd61009c21d0bb$export$7e0eeb9da702a085","copy","res","type","key","rect","estimatedSize","opacity","transform","parentKey","isSticky","zIndex","allowOverflow","constructor","$3041db3296945e6e$export$baf26146a414f24a","x","y","equals","point","isOrigin","$60423f92c7f9ad87$export$c79fc6492f3af13d","maxX","maxY","area","topLeft","topRight","bottomLeft","bottomRight","intersects","containsRect","containsPoint","getCornerInRect","pointEquals","sizeEquals","size","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","other","$ad1d98aa8f0c31b4$var$KEY","$ad1d98aa8f0c31b4$export$1a5223887c560441","prepareForReuse","content","rendered","virtualizer","$3eb131dcf37ad5f8$var$perf","window","performance","$3eb131dcf37ad5f8$var$perfNow","now","webkitNow","msNow","mozNow","$3eb131dcf37ad5f8$var$getTime","bind","Date","getTime","$3eb131dcf37ad5f8$var$fixTs","$3eb131dcf37ad5f8$export$dc0b63720788090c","begin","end","duration","ease","fn","canceled","raf_id","promise","Promise","resolve","start","diffX","diffY","requestAnimationFrame","run","t","delta","proceed","cancel","cancelAnimationFrame","$3eb131dcf37ad5f8$export$77860c106b4a6a2e","$3eb131dcf37ad5f8$export$57636bb43b1ccbb0","Math","sin","PI","$fc36f9a046a9ce79$export$37a26b283fd7740e","a","b","Set","keys","has","add","$fc36f9a046a9ce79$export$acaf96a27438246b","toRemove","toAdd","toUpdate","$fc36f9a046a9ce79$export$cfc14088dfefce5f","iterators","iterator","$fc36f9a046a9ce79$export$6897c284b6f9f4dc","object","$364191b3decf3697$var$RollingAverage","addSample","sample","count","value","$364191b3decf3697$export$4455ee6afb38dcbb","setVisibleRect","time","startTime","averageTime","visibleRect","velocity","collectMetrics","averagePerf","o","abs","overscanY","overscanX","getOverscannedRect","overscanned","round","min","$8e135e531d8dcb66$export$febc5573c75cefb0","level","actions","animated","initialMap","Map","finalMap","initialLayoutInfo","finalLayoutInfo","removed","$38b9490c1cca8fc4$export$89be5a243e59c4b2","_setContentSize","_contentSize","delegate","setContentSize","_setContentOffset","offset","_visibleRect","contentSize","_setVisibleRect","forceUpdate","current","shouldOverscan","_overscanManager","layout","_resetAnimatedContentOffset","relayout","offsetChanged","sizeChanged","updateSubviews","collection","_collection","data","_setData","_runTransaction","transitionDuration","reloadData","contentChanged","getItem","_layout","setLayout","applyLayout","_getReuseType","getType","reuseType","getReusableView","_reusableViews","reusable","view","length","pop","viewType","_animatedContentOffset","_renderView","reusableView","_renderContent","cached","_renderedContent","get","renderView","set","visibleViews","Array","from","_visibleViews","values","getView","getViewsOfType","filter","v","keyForView","keyAtPoint","layoutInfos","getVisibleLayoutInfos","willUnmount","_relayoutRaf","context","_scrollAnimation","_invalidationContext","Object","assign","relayoutNow","scrollAnchor","_getScrollAnchor","beforeLayout","getContentSize","afterLayout","getVisibleRect","restoredScrollAnchor","_restoreScrollAnchor","contentOffsetX","contentOffsetY","max","hasLayoutUpdates","transaction","_applyLayoutInfos","_enableTransitions","done","_disableTransitions","afterAnimation","setTimeout","_correctItemOrder","_isScrolling","_transaction","_visibleLayoutInfos","_children","delete","beginAnimations","endAnimations","anchorScrollPosition","getScrollAnchor","getLayoutInfo","corner","anchorScrollPositionAtTop","cornerAnchor","contentOffset","ref","finalAnchor","adjustment","_getLayoutInfoMap","map","visibleLayoutInfos","currentlyVisible","item","reuseView","key1","_applyLayoutInfo","key2","removeViews","_flushVisibleViews","_hasLayoutUpdates","afterRender","viewsByParentKey","view1","push","buildTree","parent","views","children","renderWrapper","childViews","children1","setVisibleViews","updated","cur","view2","updateItemSize","_sizeUpdateQueue","changed","startScrolling","endScrolling","scrollToItem","options","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","scrollTo","offset1","then","clear","_processTransactionQueue","action","_startTransaction","_nextTransaction","_endTransaction","_transactionQueue","next","shift","_performTransaction","_getContentRect","_setupTransactionAnimations","key3","layoutInfo1","key4","WeakMap","_transitionDuration","$fc0b13b484ac1194$export$1505db82fe357e65","opts","$8D3nr$useState","isAnimating","setAnimating","isScrolling","setScrolling","$8D3nr$useMemo","onVisibleRectChange","$8D3nr$useLayoutEffect","$8D3nr$useEffect","$8D3nr$useCallback"],"sources":["C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Layout.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\LayoutInfo.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Point.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Rect.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Size.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\ReusableView.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\tween.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\utils.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\OverscanManager.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Transaction.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\Virtualizer.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\virtualizer\\dist\\packages\\@react-stately\\virtualizer\\src\\useVirtualizerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {InvalidationContext} from './types';\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\n// import {Point} from './Point';\nimport {Rect} from './Rect';\nimport {Size} from './Size';\nimport {Virtualizer} from './Virtualizer';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\nexport abstract class Layout<T extends object> {\n  /** The CollectionView the layout is currently attached to. */\n  virtualizer: Virtualizer<T, any, any>;\n\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width\n        || newRect.height !== oldRect.height;\n  }\n\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n  validate(invalidationContext: InvalidationContext<T, any>) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n  abstract getVisibleLayoutInfos(rect: Rect): LayoutInfo[];\n\n  /**\n   * Returns a {@link LayoutInfo} for the given key.\n   * Should be implemented by subclasses.\n   * @param key The key of the LayoutInfo to retrieve.\n   */\n  abstract getLayoutInfo(key: Key): LayoutInfo;\n\n  /**\n   * Returns size of the content. By default, it returns collectionView's size.\n   */\n  abstract getContentSize(): Size;\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n  getInitialLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n  getFinalLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {Rect} from './Rect';\n\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n  type: string;\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n  key: Key;\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n  parentKey: Key | null;\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n  rect: Rect;\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n  estimatedSize: boolean;\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n  isSticky: boolean;\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n  opacity: number;\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n  transform: string | null;\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n  zIndex: number;\n\n  /**\n   * Whether the layout info allows its contents to overflow its container.\n   * @default false\n   */\n  allowOverflow: boolean;\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type: string, key: Key, rect: Rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n  copy(): LayoutInfo {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Point {\n  /** The x-coordinate of the point. */\n  x: number;\n\n  /** The y-coordinate of the point. */\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns a copy of this point.\n   */\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Checks if two points are equal.\n   */\n  equals(point: Point): boolean {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  /**\n   * Returns true if this point is the origin.\n   */\n  isOrigin(): boolean {\n    return this.x === 0 && this.y === 0;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Size} from './Size';\n\nexport type RectCorner = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\n/**\n * Represents a rectangle.\n */\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n  x: number;\n\n  /** The y-coordinate of the rectangle. */\n  y: number;\n\n  /** The width of the rectangle. */\n  width: number;\n\n  /** The height of the rectangle. */\n  height: number;\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n  get maxX(): number {\n    return this.x + this.width;\n  }\n\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n  get maxY(): number {\n    return this.y + this.height;\n  }\n\n  /**\n   * The area of the rectangle.\n   */\n  get area(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * The top left corner of the rectangle.\n   */\n  get topLeft(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * The top right corner of the rectangle.\n   */\n  get topRight(): Point {\n    return new Point(this.maxX, this.y);\n  }\n\n  /**\n   * The bottom left corner of the rectangle.\n   */\n  get bottomLeft(): Point {\n    return new Point(this.x, this.maxY);\n  }\n\n  /**\n   * The bottom right corner of the rectangle.\n   */\n  get bottomRight(): Point {\n    return new Point(this.maxX, this.maxY);\n  }\n\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  intersects(rect: Rect): boolean {\n    return this.x <= rect.x + rect.width\n        && rect.x <= this.x + this.width\n        && this.y <= rect.y + rect.height\n        && rect.y <= this.y + this.height;\n  }\n\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  containsRect(rect: Rect): boolean {\n    return this.x <= rect.x\n        && this.y <= rect.y\n        && this.maxX >= rect.maxX\n        && this.maxY >= rect.maxY;\n  }\n\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n  containsPoint(point: Point): boolean {\n    return this.x <= point.x\n        && this.y <= point.y\n        && this.maxX >= point.x\n        && this.maxY >= point.y;\n  }\n\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n  getCornerInRect(rect: Rect): RectCorner | null {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key as RectCorner;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect: Rect) {\n    return rect.x === this.x\n        && rect.y === this.y\n        && rect.width === this.width\n        && rect.height === this.height;\n  }\n\n  pointEquals(point: Point | Rect) {\n    return this.x === point.x\n        && this.y === point.y;\n  }\n\n  sizeEquals(size: Size | Rect) {\n    return this.width === size.width\n        && this.height === size.height;\n  }\n\n  /**\n   * Returns a copy of this rectangle.\n   */\n  copy(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Size {\n  width: number;\n  height: number;\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Returns a copy of this size.\n   */\n  copy(): Size {\n    return new Size(this.width, this.height);\n  }\n\n  /**\n   * Returns whether this size is equal to another one.\n   */\n  equals(other: Size): boolean {\n    return this.width === other.width\n        && this.height === other.height;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {Virtualizer} from './Virtualizer';\n\nlet KEY = 0;\n\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\nexport class ReusableView<T extends object, V> {\n  /** The CollectionVirtualizer this view is a part of. */\n  virtualizer: Virtualizer<T, V, unknown>;\n\n  /** The LayoutInfo this view is currently representing. */\n  layoutInfo: LayoutInfo | null;\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  content: T;\n\n  rendered: V;\n\n  viewType: string;\n  key: Key;\n\n  constructor(virtualizer: Virtualizer<T, V, unknown>) {\n    this.virtualizer = virtualizer;\n    this.key = ++KEY;\n  }\n\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\n\n// use high res timer if available\nlet perf = typeof window !== 'undefined' ? window.performance : null;\n// @ts-ignore\nlet perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);\nlet getTime = perfNow ? perfNow.bind(perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\n\nlet fixTs: boolean;\n\nexport interface CancelablePromise<T> extends Promise<T> {\n  cancel(): void\n}\n\nexport function tween(begin, end, duration, ease, fn): CancelablePromise<void> {\n  let canceled = false;\n  let raf_id: number;\n\n  let promise = new Promise(resolve => {\n    let start = getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if (fixTs == null) {\n        fixTs = t > 1e12 !== getTime() > 1e12;\n      }\n\n      if (fixTs) {\n        t = getTime();\n      }\n\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(\n          begin.x + diffX * ease(delta / duration),\n          begin.y + diffY * ease(delta / duration)\n        ));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  }) as CancelablePromise<void>;\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\n// easing functions\nexport function linearEasing(t) {\n  return t;\n}\n\nexport function easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function keyDiff<T>(a: Map<T, any>, b: Map<T, any>): Set<T> {\n  let res = new Set<T>();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\nexport function difference<T>(a: Map<T, any>, b: Map<T, any>) {\n  let toRemove = keyDiff(a, b);\n  let toAdd = keyDiff(b, a);\n  let toUpdate = new Set;\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n  return {toRemove, toAdd, toUpdate};\n}\n\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\nexport function* concatIterators<T>(...iterators: Iterable<T>[]) {\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n\n/**\n * Inverts the keys and values of an object.\n * @private\n */\nexport function invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Rect} from './Rect';\n\nclass RollingAverage {\n  private count: number = 0;\n  value: number = 0;\n  \n  addSample(sample: number) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n}\n\nexport class OverscanManager {\n  private startTime = 0;\n  private averagePerf = new RollingAverage();\n  private averageTime = new RollingAverage();\n  private velocity = new Point(5, 5);\n  private overscanX = new RollingAverage();\n  private overscanY = new RollingAverage();\n  private visibleRect = new Rect();\n  \n  setVisibleRect(rect: Rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {ReusableView} from './ReusableView';\n\ntype LayoutInfoMap = Map<Key, LayoutInfo>;\nexport class Transaction<T extends object, V> {\n  level = 0;\n  actions: (() => void)[] = [];\n  animated = true;\n  initialMap: LayoutInfoMap = new Map();\n  finalMap: LayoutInfoMap = new Map();\n  initialLayoutInfo: LayoutInfoMap = new Map();\n  finalLayoutInfo: LayoutInfoMap = new Map();\n  removed: Map<Key, ReusableView<T, V>> = new Map();\n  toRemove: Map<Key, ReusableView<T, V>> = new Map();\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection} from '@react-types/shared';\nimport {concatIterators, difference} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Key} from 'react';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    let layoutInfo = layoutInfos[0];\n    if (!layoutInfo) {\n      return null;\n    }\n\n    return layoutInfo.key;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (!viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo.parentKey).push(view);\n      if (!viewsByParentKey.has(view.layoutInfo.key)) {\n        viewsByParentKey.set(view.layoutInfo.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop. The resize buffer (\"spooky column\") often has a width of 0.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useState} from 'react';\nimport {Layout} from './Layout';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {Virtualizer} from './Virtualizer';\n\ninterface VirtualizerProps<T extends object, V, W> {\n  renderView(type: string, content: T): V,\n  renderWrapper(\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => W[]\n  ): W,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  onVisibleRectChange(rect: Rect): void,\n  getScrollAnchor?(rect: Rect): Key,\n  transitionDuration?: number\n}\n\nexport interface VirtualizerState<T extends object, V, W> {\n  visibleViews: W[],\n  setVisibleRect: (rect: Rect) => void,\n  contentSize: Size,\n  isAnimating: boolean,\n  virtualizer: Virtualizer<T, V, W>,\n  isScrolling: boolean,\n  startScrolling: () => void,\n  endScrolling: () => void\n}\n\nexport function useVirtualizerState<T extends object, V, W>(opts: VirtualizerProps<T, V, W>): VirtualizerState<T, V, W> {\n  let [visibleViews, setVisibleViews] = useState<W[]>([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new Virtualizer<T, V, W>(), []);\n\n  virtualizer.delegate = {\n    setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  });\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  }, []);\n\n  return {\n    virtualizer,\n    visibleViews,\n    setVisibleRect: useCallback((rect) => {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling: useCallback(() => {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: useCallback(() => {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n"]},"metadata":{},"sourceType":"module"}