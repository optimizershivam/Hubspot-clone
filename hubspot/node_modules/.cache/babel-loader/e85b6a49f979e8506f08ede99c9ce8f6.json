{"ast":null,"code":"import { useState as $6imuh$useState, useRef as $6imuh$useRef, useCallback as $6imuh$useCallback } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $458b0a5536c1a7cf$exports = {};\n$parcel$export($458b0a5536c1a7cf$exports, \"useControlledState\", () => $458b0a5536c1a7cf$export$40bfa8c7b0832715);\n\nfunction $458b0a5536c1a7cf$export$40bfa8c7b0832715(value1, defaultValue, onChange) {\n  let [stateValue, setStateValue] = $6imuh$useState(value1 || defaultValue);\n  let ref = $6imuh$useRef(value1 !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value1 !== undefined; // Internal state reference for useCallback\n\n  let stateRef = $6imuh$useRef(stateValue);\n  if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  ref.current = isControlled;\n  let setValue = $6imuh$useCallback(function (value2) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    let onChangeCaller = function (value) {\n      if (onChange) {\n        for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          onChangeArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        if (!Object.is(stateRef.current, value)) onChange(value, ...onChangeArgs);\n      }\n\n      if (!isControlled) stateRef.current = value;\n    };\n\n    if (typeof value2 === 'function') {\n      console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320'); // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n\n      let updateFunction = function (oldValue) {\n        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          functionArgs[_key3 - 1] = arguments[_key3];\n        }\n\n        let interceptedValue = value2(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) return interceptedValue;\n        return oldValue;\n      };\n\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) setStateValue(value2);\n      onChangeCaller(value2, ...args);\n    }\n  }, [isControlled, onChange]); // If a controlled component's value prop changes, we need to update stateRef\n\n  if (isControlled) stateRef.current = value1;else value1 = stateValue;\n  return [value1, setValue];\n}\n\nvar $9446cca9a3875146$exports = {};\n$parcel$export($9446cca9a3875146$exports, \"clamp\", () => $9446cca9a3875146$export$7d15b64cf5a3a4c4);\n$parcel$export($9446cca9a3875146$exports, \"snapValueToStep\", () => $9446cca9a3875146$export$cb6e0bb50bc19463);\n$parcel$export($9446cca9a3875146$exports, \"toFixedNumber\", () => $9446cca9a3875146$export$b6268554fba451f);\n\nfunction $9446cca9a3875146$export$7d15b64cf5a3a4c4(value) {\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) snappedValue = min;else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n  } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step; // correct floating point behavior by rounding to step precision\n\n\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits) {\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\n\nexport { $458b0a5536c1a7cf$export$40bfa8c7b0832715 as useControlledState, $9446cca9a3875146$export$7d15b64cf5a3a4c4 as clamp, $9446cca9a3875146$export$cb6e0bb50bc19463 as snapValueToStep, $9446cca9a3875146$export$b6268554fba451f as toFixedNumber };","map":{"version":3,"mappings":"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","names":["$458b0a5536c1a7cf$export$40bfa8c7b0832715","value1","defaultValue","onChange","stateValue","setStateValue","$6imuh$useState","ref","$6imuh$useRef","undefined","wasControlled","current","isControlled","stateRef","console","warn","setValue","$6imuh$useCallback","value2","args","onChangeCaller","value","onChangeArgs","Object","is","updateFunction","oldValue","functionArgs","interceptedValue","$9446cca9a3875146$export$7d15b64cf5a3a4c4","min","Infinity","max","newValue","Math","$9446cca9a3875146$export$cb6e0bb50bc19463","step","remainder","isNaN","snappedValue","abs","sign","floor","string","toString","index","indexOf","precision","length","pow","round","$9446cca9a3875146$export$b6268554fba451f","digits","base"],"sources":["C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\useControlledState.ts","C:\\Users\\Tejaswini Mahale\\Desktop\\Hubspot\\hubspot\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\number.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T, ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"module"}