import { useTheme } from '@chakra-ui/system';
import { isFunction, __DEV__, memoizedGet, isObject, breakpoints, isArray, fromEntries, arrayToObjectNotation } from '@chakra-ui/utils';
import * as React from 'react';
import { useState, useEffect } from 'react';
import { useEnvironment } from '@chakra-ui/react-env';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * React hook that tracks state of a CSS media query
 *
 * @param query the media query to match
 * @param options the media query options { fallback, ssr }
 */
function useMediaQuery(query, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$ssr = _options.ssr,
      ssr = _options$ssr === void 0 ? true : _options$ssr,
      fallback = _options.fallback;
  var env = useEnvironment();
  var queries = Array.isArray(query) ? query : [query];
  var fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
  fallbackValues = fallbackValues.filter(function (v) {
    return v != null;
  });

  var _useState = useState(function () {
    return queries.map(function (query, index) {
      return {
        media: query,
        matches: ssr ? !!fallbackValues[index] : env.window.matchMedia(query).matches
      };
    });
  }),
      value = _useState[0],
      setValue = _useState[1];

  useEffect(function () {
    setValue(queries.map(function (query) {
      return {
        media: query,
        matches: env.window.matchMedia(query).matches
      };
    }));
    var mql = queries.map(function (query) {
      return env.window.matchMedia(query);
    });

    var handler = function handler(evt) {
      setValue(function (prev) {
        return prev.slice().map(function (item) {
          if (item.media === evt.media) return _extends({}, item, {
            matches: evt.matches
          });
          return item;
        });
      });
    };

    mql.forEach(function (mql) {
      if (isFunction(mql.addListener)) mql.addListener(handler);else mql.addEventListener("change", handler);
    });
    return function () {
      mql.forEach(function (mql) {
        if (isFunction(mql.removeListener)) mql.removeListener(handler);else mql.removeEventListener("change", handler);
      });
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [env.window]);
  return value.map(function (item) {
    return item.matches;
  });
}

/**
 * Visibility
 *
 * React component to control the visibility of its
 * children based on the current breakpoint
 */
var Visibility = function Visibility(props) {
  var breakpoint = props.breakpoint,
      hide = props.hide,
      children = props.children,
      ssr = props.ssr;

  var _useMediaQuery = useMediaQuery(breakpoint, {
    ssr: ssr
  }),
      show = _useMediaQuery[0];

  var isVisible = hide ? !show : show;
  var rendered = isVisible ? children : null;
  return rendered;
};

var Hide = function Hide(props) {
  var children = props.children,
      ssr = props.ssr;
  var query = useQuery(props);
  return /*#__PURE__*/React.createElement(Visibility, {
    breakpoint: query,
    hide: true,
    ssr: ssr
  }, children);
};

if (__DEV__) {
  Hide.displayName = "Hide";
}

var Show = function Show(props) {
  var children = props.children,
      ssr = props.ssr;
  var query = useQuery(props);
  return /*#__PURE__*/React.createElement(Visibility, {
    breakpoint: query,
    ssr: ssr
  }, children);
};

if (__DEV__) {
  Show.displayName = "Show";
}

var getBreakpoint = function getBreakpoint(theme, value) {
  return memoizedGet(theme, "breakpoints." + value, value);
};

function useQuery(props) {
  var _props$breakpoint = props.breakpoint,
      breakpoint = _props$breakpoint === void 0 ? "" : _props$breakpoint,
      below = props.below,
      above = props.above;
  var theme = useTheme();
  var bpBelow = getBreakpoint(theme, below);
  var bpAbove = getBreakpoint(theme, above);
  var query = breakpoint;

  if (bpBelow) {
    query = "(max-width: " + bpBelow + ")";
  } else if (bpAbove) {
    query = "(min-width: " + bpAbove + ")";
  }

  return query;
}

/**
 * React hook used to get the user's animation preference.
 */

function usePrefersReducedMotion(options) {
  var _useMediaQuery = useMediaQuery("(prefers-reduced-motion: reduce)", options),
      prefersReducedMotion = _useMediaQuery[0];

  return prefersReducedMotion;
}
/**
 * React hook for getting the user's color mode preference.
 */

function useColorModePreference(options) {
  var _useMediaQuery2 = useMediaQuery(["(prefers-color-scheme: light)", "(prefers-color-scheme: dark)"], options),
      isLight = _useMediaQuery2[0],
      isDark = _useMediaQuery2[1];

  if (isLight) return "light";
  if (isDark) return "dark";
  return undefined;
}

/**
 * React hook used to get the current responsive media breakpoint.
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent.
 */
function useBreakpoint(arg) {
  var _breakpoints$index$br, _breakpoints$index;

  var opts = isObject(arg) ? arg : {
    fallback: arg != null ? arg : "base"
  };
  var theme = useTheme();

  var breakpoints = theme.__breakpoints.details.map(function (_ref) {
    var minMaxQuery = _ref.minMaxQuery,
        breakpoint = _ref.breakpoint;
    return {
      breakpoint: breakpoint,
      query: minMaxQuery.replace("@media screen and ", "")
    };
  });

  var fallback = breakpoints.map(function (bp) {
    return bp.breakpoint === opts.fallback;
  });
  var values = useMediaQuery(breakpoints.map(function (bp) {
    return bp.query;
  }), {
    fallback: fallback,
    ssr: opts.ssr
  });
  var index = values.findIndex(function (value) {
    return value == true;
  });
  return (_breakpoints$index$br = (_breakpoints$index = breakpoints[index]) == null ? void 0 : _breakpoints$index.breakpoint) != null ? _breakpoints$index$br : opts.fallback;
}

function getClosestValue(values, breakpoint, breakpoints$1) {
  if (breakpoints$1 === void 0) {
    breakpoints$1 = breakpoints;
  }

  var index = Object.keys(values).indexOf(breakpoint);

  if (index !== -1) {
    return values[breakpoint];
  }

  var stopIndex = breakpoints$1.indexOf(breakpoint);

  while (stopIndex >= 0) {
    var key = breakpoints$1[stopIndex];

    if (values.hasOwnProperty(key)) {
      index = stopIndex;
      break;
    }

    stopIndex -= 1;
  }

  if (index !== -1) {
    var _key = breakpoints$1[index];
    return values[_key];
  }

  return undefined;
}

/**
 * React hook for getting the value for the current breakpoint from the
 * provided responsive values object.
 *
 * For SSR, you can use a package like [is-mobile](https://github.com/kaimallea/isMobile)
 * to get the default breakpoint value from the user-agent
 *
 * @example
 * const width = useBreakpointValue({ base: '150px', md: '250px' })
 */

function useBreakpointValue(values, arg) {
  var _theme$__breakpoints;

  var opts = isObject(arg) ? arg : {
    fallback: arg != null ? arg : "base"
  };
  var breakpoint = useBreakpoint(opts);
  var theme = useTheme();
  if (!breakpoint) return;
  /**
   * Get the sorted breakpoint keys from the provided breakpoints
   */

  var breakpoints = Array.from(((_theme$__breakpoints = theme.__breakpoints) == null ? void 0 : _theme$__breakpoints.keys) || []);
  var obj = isArray(values) ? fromEntries(Object.entries(arrayToObjectNotation(values, breakpoints)).map(function (_ref) {
    var key = _ref[0],
        value = _ref[1];
    return [key, value];
  })) : values;
  return getClosestValue(obj, breakpoint, breakpoints);
}

export { Hide, Show, useBreakpoint, useBreakpointValue, useColorModePreference, useMediaQuery, usePrefersReducedMotion, useQuery };
