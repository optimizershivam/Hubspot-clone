import { chakra, useChakra, ThemeProvider, ColorModeContext } from '@chakra-ui/system';
import * as React from 'react';
import { Alert, AlertIcon, AlertTitle, AlertDescription } from '@chakra-ui/alert';
import { CloseButton } from '@chakra-ui/close-button';
import { isFunction, runIfFn, __DEV__, objectKeys, noop } from '@chakra-ui/utils';
import { useIsPresent, motion, AnimatePresence } from 'framer-motion';
import { Portal } from '@chakra-ui/portal';
import { useUpdateEffect, useTimeout } from '@chakra-ui/hooks';
import defaultTheme from '@chakra-ui/theme';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function getToastPlacement(position, dir) {
  var _logical$dir;

  var computedPosition = position != null ? position : "bottom";
  var logicals = {
    "top-start": {
      ltr: "top-left",
      rtl: "top-right"
    },
    "top-end": {
      ltr: "top-right",
      rtl: "top-left"
    },
    "bottom-start": {
      ltr: "bottom-left",
      rtl: "bottom-right"
    },
    "bottom-end": {
      ltr: "bottom-right",
      rtl: "bottom-left"
    }
  };
  var logical = logicals[computedPosition];
  return (_logical$dir = logical == null ? void 0 : logical[dir]) != null ? _logical$dir : computedPosition;
}

/**
 * Given an array of toasts for a specific position.
 * It returns the toast that matches the `id` passed
 */
/**
 * Given the toast manager state, finds the toast that matches
 * the id and return its position and index
 */

function findToast(toasts, id) {
  var position = getToastPosition(toasts, id);
  var index = position ? toasts[position].findIndex(function (toast) {
    return toast.id === id;
  }) : -1;
  return {
    position: position,
    index: index
  };
}
/**
 * Given the toast manager state, finds the position of the toast that
 * matches the `id`
 */

var getToastPosition = function getToastPosition(toasts, id) {
  var _Object$values$flat$f;

  return (_Object$values$flat$f = Object.values(toasts).flat().find(function (toast) {
    return toast.id === id;
  })) == null ? void 0 : _Object$values$flat$f.position;
};
/**
 * Gets the styles to be applied to a toast's container
 * based on its position in the manager
 */

function getToastStyle(position) {
  var isRighty = position.includes("right");
  var isLefty = position.includes("left");
  var alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems: alignItems
  };
}
/**
 * Compute the style of a toast based on its position
 */

function getToastListStyle(position) {
  var isTopOrBottom = position === "top" || position === "bottom";
  var margin = isTopOrBottom ? "0 auto" : undefined;
  var top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : undefined;
  var bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : undefined;
  var right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : undefined;
  var left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : undefined;
  return {
    position: "fixed",
    zIndex: 5500,
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin: margin,
    top: top,
    bottom: bottom,
    right: right,
    left: left
  };
}

var initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
/**
 * Store to track all the toast across all positions
 */

var toastStore = createStore(initialState);

function createStore(initialState) {
  var state = initialState;
  var listeners = new Set();

  var setState = function setState(setStateFn) {
    state = setStateFn(state);
    listeners.forEach(function (l) {
      return l();
    });
  };

  return {
    getState: function getState() {
      return state;
    },
    subscribe: function subscribe(listener) {
      listeners.add(listener);
      return function () {
        // Delete all toasts on unmount
        setState(function () {
          return initialState;
        });
        listeners["delete"](listener);
      };
    },

    /**
     * Delete a toast record at its position
     */
    removeToast: function removeToast(id, position) {
      setState(function (prevState) {
        var _extends2;

        return _extends({}, prevState, (_extends2 = {}, _extends2[position] = prevState[position].filter(function (toast) {
          return toast.id != id;
        }), _extends2));
      });
    },
    notify: function notify(message, options) {
      var toast = createToast(message, options);
      var position = toast.position,
          id = toast.id;
      setState(function (prevToasts) {
        var _prevToasts$position, _prevToasts$position2, _extends3;

        var isTop = position.includes("top");
        /**
         * - If the toast is positioned at the top edges, the
         * recent toast stacks on top of the other toasts.
         *
         * - If the toast is positioned at the bottom edges, the recent
         * toast stacks below the other toasts.
         */

        var toasts = isTop ? [toast].concat((_prevToasts$position = prevToasts[position]) != null ? _prevToasts$position : []) : [].concat((_prevToasts$position2 = prevToasts[position]) != null ? _prevToasts$position2 : [], [toast]);
        return _extends({}, prevToasts, (_extends3 = {}, _extends3[position] = toasts, _extends3));
      });
      return id;
    },
    update: function update(id, options) {
      if (!id) return;
      setState(function (prevState) {
        var nextState = _extends({}, prevState);

        var _findToast = findToast(nextState, id),
            position = _findToast.position,
            index = _findToast.index;

        if (position && index !== -1) {
          nextState[position][index] = _extends({}, nextState[position][index], options, {
            message: createRenderToast(options)
          });
        }

        return nextState;
      });
    },
    closeAll: function closeAll(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          positions = _ref.positions;

      // only one setState here for perf reasons
      // instead of spamming this.closeToast
      setState(function (prev) {
        var allPositions = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
        var positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce(function (acc, position) {
          acc[position] = prev[position].map(function (toast) {
            return _extends({}, toast, {
              requestClose: true
            });
          });
          return acc;
        }, _extends({}, prev));
      });
    },
    close: function close(id) {
      setState(function (prevState) {
        var _extends4;

        var position = getToastPosition(prevState, id);
        if (!position) return prevState;
        return _extends({}, prevState, (_extends4 = {}, _extends4[position] = prevState[position].map(function (toast) {
          // id may be string or number
          // eslint-disable-next-line eqeqeq
          if (toast.id == id) {
            return _extends({}, toast, {
              requestClose: true
            });
          }

          return toast;
        }), _extends4));
      });
    },
    isActive: function isActive(id) {
      return Boolean(findToast(toastStore.getState(), id).position);
    }
  };
}
/**
 * Static id counter to create unique ids
 * for each toast
 */


var counter = 0;
/**
 * Create properties for a new toast
 */

function createToast(message, options) {
  var _options$id, _options$position;

  if (options === void 0) {
    options = {};
  }

  counter += 1;
  var id = (_options$id = options.id) != null ? _options$id : counter;
  var position = (_options$position = options.position) != null ? _options$position : "bottom";
  return {
    id: id,
    message: message,
    position: position,
    duration: options.duration,
    onCloseComplete: options.onCloseComplete,
    onRequestRemove: function onRequestRemove() {
      return toastStore.removeToast(String(id), position);
    },
    status: options.status,
    requestClose: false,
    containerStyle: options.containerStyle
  };
}

var Toast = function Toast(props) {
  var status = props.status,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? "solid" : _props$variant,
      id = props.id,
      title = props.title,
      isClosable = props.isClosable,
      onClose = props.onClose,
      description = props.description,
      icon = props.icon;
  var alertTitleId = typeof id !== "undefined" ? "toast-" + id + "-title" : undefined;
  return /*#__PURE__*/React.createElement(Alert, {
    status: status,
    variant: variant,
    id: String(id),
    alignItems: "start",
    borderRadius: "md",
    boxShadow: "lg",
    paddingEnd: 8,
    textAlign: "start",
    width: "auto",
    "aria-labelledby": alertTitleId
  }, /*#__PURE__*/React.createElement(AlertIcon, null, icon), /*#__PURE__*/React.createElement(chakra.div, {
    flex: "1",
    maxWidth: "100%"
  }, title && /*#__PURE__*/React.createElement(AlertTitle, {
    id: alertTitleId
  }, title), description && /*#__PURE__*/React.createElement(AlertDescription, {
    display: "block"
  }, description)), isClosable && /*#__PURE__*/React.createElement(CloseButton, {
    size: "sm",
    onClick: onClose,
    position: "absolute",
    insetEnd: 1,
    top: 1
  }));
};
function createRenderToast(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      render = _options.render,
      _options$toastCompone = _options.toastComponent,
      ToastComponent = _options$toastCompone === void 0 ? Toast : _options$toastCompone;

  var renderToast = function renderToast(props) {
    if (isFunction(render)) {
      return render(props);
    }

    return /*#__PURE__*/React.createElement(ToastComponent, _extends({}, props, options));
  };

  return renderToast;
}
function createToastFn(dir, defaultOptions) {
  var normalizeToastOptions = function normalizeToastOptions(options) {
    var _options$position;

    return _extends({}, defaultOptions, options, {
      position: getToastPlacement((_options$position = options == null ? void 0 : options.position) != null ? _options$position : defaultOptions == null ? void 0 : defaultOptions.position, dir)
    });
  };

  var toast = function toast(options) {
    var normalizedToastOptions = normalizeToastOptions(options);
    var Message = createRenderToast(normalizedToastOptions);
    return toastStore.notify(Message, normalizedToastOptions);
  };

  toast.update = function (id, options) {
    toastStore.update(id, normalizeToastOptions(options));
  };

  toast.promise = function (promise, options) {
    var id = toast(_extends({}, options.loading, {
      status: "loading",
      duration: null
    }));
    promise.then(function (data) {
      return toast.update(id, _extends({
        status: "success",
        duration: 5000
      }, runIfFn(options.success, data)));
    })["catch"](function (error) {
      return toast.update(id, _extends({
        status: "error",
        duration: 5000
      }, runIfFn(options.error, error)));
    });
  };

  toast.closeAll = toastStore.closeAll;
  toast.close = toastStore.close;
  toast.isActive = toastStore.isActive;
  return toast;
}

/**
 * React hook used to create a function that can be used
 * to show toasts in an application.
 */
function useToast(defaultOptions) {
  var _useChakra = useChakra(),
      theme = _useChakra.theme;

  return React.useMemo(function () {
    return createToastFn(theme.direction, defaultOptions);
  }, [defaultOptions, theme.direction]);
}

var toastMotionVariants = {
  initial: function initial(props) {
    var _ref;

    var position = props.position;
    var dir = ["top", "bottom"].includes(position) ? "y" : "x";
    var factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
    if (position === "bottom") factor = 1;
    return _ref = {
      opacity: 0
    }, _ref[dir] = factor * 24, _ref;
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = /*#__PURE__*/React.memo(function (props) {
  var id = props.id,
      message = props.message,
      onCloseComplete = props.onCloseComplete,
      onRequestRemove = props.onRequestRemove,
      _props$requestClose = props.requestClose,
      requestClose = _props$requestClose === void 0 ? false : _props$requestClose,
      _props$position = props.position,
      position = _props$position === void 0 ? "bottom" : _props$position,
      _props$duration = props.duration,
      duration = _props$duration === void 0 ? 5000 : _props$duration,
      containerStyle = props.containerStyle,
      _props$motionVariants = props.motionVariants,
      motionVariants = _props$motionVariants === void 0 ? toastMotionVariants : _props$motionVariants,
      _props$toastSpacing = props.toastSpacing,
      toastSpacing = _props$toastSpacing === void 0 ? "0.5rem" : _props$toastSpacing;

  var _React$useState = React.useState(duration),
      delay = _React$useState[0],
      setDelay = _React$useState[1];

  var isPresent = useIsPresent();
  useUpdateEffect(function () {
    if (!isPresent) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent]);
  useUpdateEffect(function () {
    setDelay(duration);
  }, [duration]);

  var onMouseEnter = function onMouseEnter() {
    return setDelay(null);
  };

  var onMouseLeave = function onMouseLeave() {
    return setDelay(duration);
  };

  var close = function close() {
    if (isPresent) onRequestRemove();
  };

  React.useEffect(function () {
    if (isPresent && requestClose) {
      onRequestRemove();
    }
  }, [isPresent, requestClose, onRequestRemove]);
  useTimeout(close, delay);
  var containerStyles = React.useMemo(function () {
    return _extends({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing
    }, containerStyle);
  }, [containerStyle, toastSpacing]);
  var toastStyle = React.useMemo(function () {
    return getToastStyle(position);
  }, [position]);
  return /*#__PURE__*/React.createElement(motion.li, {
    layout: true,
    className: "chakra-toast",
    variants: motionVariants,
    initial: "initial",
    animate: "animate",
    exit: "exit",
    onHoverStart: onMouseEnter,
    onHoverEnd: onMouseLeave,
    custom: {
      position: position
    },
    style: toastStyle
  }, /*#__PURE__*/React.createElement(chakra.div, {
    role: "status",
    "aria-atomic": "true",
    className: "chakra-toast__inner",
    __css: containerStyles
  }, runIfFn(message, {
    id: id,
    onClose: close
  })));
});

if (__DEV__) {
  ToastComponent.displayName = "ToastComponent";
}

/**
 * Manages the creation, and removal of toasts
 * across all corners ("top", "bottom", etc.)
 */
var ToastProvider = function ToastProvider(props) {
  var state = React.useSyncExternalStore(toastStore.subscribe, toastStore.getState, toastStore.getState);
  var children = props.children,
      motionVariants = props.motionVariants,
      _props$component = props.component,
      Component = _props$component === void 0 ? ToastComponent : _props$component,
      portalProps = props.portalProps;
  var toastList = objectKeys(state).map(function (position) {
    var toasts = state[position];
    return /*#__PURE__*/React.createElement("ul", {
      role: "region",
      "aria-live": "polite",
      key: position,
      id: "chakra-toast-manager-" + position,
      style: getToastListStyle(position)
    }, /*#__PURE__*/React.createElement(AnimatePresence, {
      initial: false
    }, toasts.map(function (toast) {
      return /*#__PURE__*/React.createElement(Component, _extends({
        key: toast.id,
        motionVariants: motionVariants
      }, toast));
    })));
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(Portal, portalProps, toastList));
};

var defaults = {
  duration: 5000,
  variant: "solid"
};
var defaultStandaloneParam = {
  theme: defaultTheme,
  colorMode: "light",
  toggleColorMode: noop,
  setColorMode: noop,
  defaultOptions: defaults
};
/**
 * Create a toast
 */

function createStandaloneToast(_temp) {
  var _ref = _temp === void 0 ? defaultStandaloneParam : _temp,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? defaultStandaloneParam.theme : _ref$theme,
      _ref$colorMode = _ref.colorMode,
      colorMode = _ref$colorMode === void 0 ? defaultStandaloneParam.colorMode : _ref$colorMode,
      _ref$toggleColorMode = _ref.toggleColorMode,
      toggleColorMode = _ref$toggleColorMode === void 0 ? defaultStandaloneParam.toggleColorMode : _ref$toggleColorMode,
      _ref$setColorMode = _ref.setColorMode,
      setColorMode = _ref$setColorMode === void 0 ? defaultStandaloneParam.setColorMode : _ref$setColorMode,
      _ref$defaultOptions = _ref.defaultOptions,
      defaultOptions = _ref$defaultOptions === void 0 ? defaultStandaloneParam.defaultOptions : _ref$defaultOptions,
      motionVariants = _ref.motionVariants,
      toastSpacing = _ref.toastSpacing,
      component = _ref.component;

  var colorModeContextValue = {
    colorMode: colorMode,
    setColorMode: setColorMode,
    toggleColorMode: toggleColorMode
  };

  var ToastContainer = function ToastContainer() {
    return /*#__PURE__*/React.createElement(ThemeProvider, {
      theme: theme
    }, /*#__PURE__*/React.createElement(ColorModeContext.Provider, {
      value: colorModeContextValue
    }, /*#__PURE__*/React.createElement(ToastProvider, {
      defaultOptions: defaultOptions,
      motionVariants: motionVariants,
      toastSpacing: toastSpacing,
      component: component
    })));
  };

  return {
    ToastContainer: ToastContainer,
    toast: createToastFn(theme.direction, defaultOptions)
  };
}

export { Toast, ToastProvider, createRenderToast, createStandaloneToast, createToastFn, defaultStandaloneParam, getToastPlacement, useToast };
